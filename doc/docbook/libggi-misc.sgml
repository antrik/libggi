<chapter id="libggi-misc">
<title/Miscellaneous functions/

<refentry ID="ggiSetFlags">
<refmeta>
<refentrytitle><function/ggiSetFlags/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiSetFlags/
<refname/ggiGetFlags/
<refname/ggiAddFlags/
<refname/ggiRemoveFlags/
<refpurpose>Set or get flags affecting operation on a visual</refpurpose>
</refnamediv>

<refsynopsisdiv><funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>
<funcprototype>
<funcdef>int <function/ggiSetFlags/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, ggi_flags <parameter/flags/</paramdef>
</funcprototype>
<funcprototype>
<funcdef>ggi_flags <function/ggiGetFlags/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/</paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function/ggiAddFlags/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, ggi_flags <parameter/flags/</paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function/ggiRemoveFlags/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, ggi_flags <parameter/flags/</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiSetFlags/ sets the specified flags (bitwise OR'd together) on a
visual. This function is usually used to set async mode on a visual (see
below).
</para>
<para><function/ggiGetFlags/ obtains the flags currently in effect.
</para>
<para><function/ggiAddFlags/ and <function/ggiRemoveFlags/ are macros that
set or unsets the specified flags.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
<function/ggiSetFlags/, <function/ggiAddFlags/, and
<function/ggiRemoveFlags/ return <ReturnValue/0/ on success,
<ReturnValue><0</ReturnValue> on failure.</para>
<para>
<function/ggiGetFlags/ returns the current flags.
</para>
</refsect1><Refsect1>
<title>Synchronous and Asynchronous drawing modes</title>

<para>
Some visuals allow different modes with regard to when the screen is updated
and the actual drawing takes place.
</para>

<itemizedlist>
<listitem>
<para>
In synchronous mode when the drawing command returns, it is already or
will be executed very shortly. So the visible effect is that everything
is drawn immediately.  (It is not guaranteed in the strict sense in that
it is already drawn when the function call returns, but almost.)
This is the default mode for all visuals.
</para>
</listitem>

<listitem>
<para>
The asynchronous mode does not guarantee that drawing commands are
executed immediately, but is faster on many targets. 
If the visual does not support asynchronous mode, setting it has no
effect.  
</para>
<para>
To make sure that all pending graphics operations are actually done and
the screen is updated, you need to call <link linkend="ggiFlush">
<function/ggiFlush/</link>.  This call is not needed in synchronous mode.)
</para>
</listitem>
</itemizedlist>

<warning>
<para id="mansync">
On some targets such as the X target there is no real synchronous mode,
so LibGGI fakes one by periodically calling <function/ggiFlush/ in the
background.  This process can take about half the execution time of a program. 
So using synchronous mode can <emphasis>really</emphasis> slow things down.
</para>

<para>The synchronous mode is default because it is what most programmers
expect.</para>
</warning>

<para>
All operations are guaranteed to be performed in the
order given in both modes. Reordering is not done.
</para>

<para>
So the recommendation for all graphics applications is to set the
asynchronous mode.  It will be far more efficient on some platforms and will
<emphasis/never/ be worse. 
</para>

<example>
<title>Setting up asynchronous mode</title>
<programlisting>
ggiAddFlags(vis, GGIFLAG_ASYNC);	/* switches to asynchronous mode */

ggiFlush(vis);				/* updates the screen */

ggiRemoveFlags(vis, GGIFLAG_ASYNC);	/* switches to synchronous mode */
</programlisting>
</example>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist TYPE=inline>
<member>
<xref linkend="ggiFlush">
</member>
</simplelist>

</refsect1>
</refentry>



<refentry ID="ggiFlush">
<refmeta>
<refentrytitle><function/ggiFlush/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiFlush/
<refname/ggiFlushRegion/
<refpurpose>Flush pending output</refpurpose>
</refnamediv>

<refsynopsisdiv><funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>
<funcprototype>
<funcdef>int <function/ggiFlush/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiFlushRegion/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, 
int <parameter/x/, int <parameter/y/, 
int <parameter/w/, int <parameter/h/
</paramdef>
</funcprototype>

</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiFlush/ waits for the visual to finish pending accelerator
commands, and in some targets, it refreshes the framebuffer.
</para>

<para>
<function/ggiFlushRegion/ performs the flush function 
only in the specified region if it would improve performance.
</para>

<para>These functions are not needed if the visual is in synchronous mode.
</para>
</refsect1>

<refsect1>
<title>Return Value</title>
<para>
No meaningful return value.
</para>

</refsect1>

<refsect1>
<title>See Also</title>
<simplelist TYPE=inline>
<member>
<xref linkEnd="ggiSetFlags">
</member>
</simplelist>
</refsect1>

</refentry>

<refentry id="ggiResourceAcquire">
<refmeta>
<refentrytitle><function/ggiResourceAcquire/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiResourceAcquire/
<refname/ggiResourceRelease/
<refname/ggiResourceMustAcquire/
<refpurpose>Acquire and release a LibGGI resource</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>
<funcprototype>
<funcdef>int <function/ggiResourceAcquire/</funcdef>
<paramdef>ggi_resource_t <parameter/res/, uint32 <parameter/actype/</paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function/ggiResourceRelease/</funcdef>
<paramdef>ggi_resource_t <parameter/res/</paramdef>
</funcprototype>
<funcprototype>
<funcdef>int <function/ggiResourceMustAcquire/</funcdef>
<paramdef>ggi_resource_t <parameter/res/</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiResourceAcquire/ acquires (locks) a LibGGI resource, typically a
DirectBuffer (see examples below).  The <parameter/actype/ indicates the
desired access type for the operation.  The following flags may be
bitwise-or'ed together:

<variablelist>
<varlistentry>
<term><symbol/GGI_ACTYPE_READ/</term>
<listitem><para>read access to the resource</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GGI_ACTYPE_WRITE/</term>
<listitem><para>write access to the resource</para></listitem>
</varlistentry>

</variablelist>
</para>

<para>
<function/ggiResourceRelease/ releases (unlocks) an already-acquired
resource.
</para>

<para>
<function/ggiResourceMustAcquire/ determines whether or not the
specified resource needs to be acquired before using.
</para>

</refsect1>

<refsect1>
<title>Return Value</title>
<para>
<function/ggiResourceAcquire/ and <function/ggiResourceRelease/
return <ReturnValue/0/ on success, <ReturnValue><0</ReturnValue> on failure.
</para>
<para>
<function/ggiResourceMustAcquire/ is simply a macro that returns true
if the resource must be explicitly acquired and released, or false if not.
However, it is still safe to call <function/ggiResourceAcquire/ or
<function/ggiResourceRelease/ even in the latter case -- it would be a no-op.
</para>
</refsect1>

<refsect1>
<title>Examples</title>

<example>
<title>Using DirectBuffers</title>
<programlisting>
const ggi_directbuffer *dbuf;

/* Acquire DirectBuffer before we use it. */
if (ggiResourceAcquire(dbuf->resource, GGI_ACTYPE_WRITE) != 0) {
	fail("Error acquiring DirectBuffer\n");
}

<replaceable>/* Do framebuffer rendering here... */</replaceable>

/* Release DirectBuffer when done with it. */
ggiResourceRelease(dbuf->resource);

</programlisting>
</example>
</refsect1>

</refentry>
</chapter>



