<refentry id="ggiDBGetBuffer">

<refmeta>
<refentrytitle><function/ggiDBGetBuffer/</refentrytitle>
<manvolnum>3ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname/ggiDBGetNumBuffers/
<refname/ggiDBGetBuffer/
<refpurpose>Get DirectBuffers from a visual</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>
<funcprototype>
<funcdef>int <function/ggiDBGetNumBuffers/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/</paramdef>
</funcprototype>
<funcprototype>
<funcdef>const ggi_directbuffer *<function/ggiDBGetBuffer/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, int <parameter/bufnum/
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiDBGetNumBuffers/ returns the number of DirectBuffers available
to the application.

<function/ggiDBGetBuffer/ obtains the DirectBuffer at the specified
position.
</para>
<para>
Use <function/ggiDBGetBuffer/ to obtain the DirectBuffers at 0 to
n-1, where n is the number returned by <function/ggiDBGetNumBuffers/.
</para>
<para>
Pixel-linear buffers have <literal/type==GGI_DB_SIMPLE_PLB | GGI_DB_NORMAL/.
You're on your own now.
</para>

<para>
DirectBuffers where <function/ggiResourceMustAcquire/ is true need to be
'acquired' (i.e. locked) before using.  An acquire is done by using
<function/ggiResourceAcquire/ and is released by calling
<function/ggiResourceRelease/.  
(See <xref linkend="ggiResourceAcquire">.)

Beware that the <structfield/read/, <structfield/write/ and
<structfield/stride/ fields of the DirectBuffer may be changed by an
acquire, and that they may be <symbol/NULL/ or invalid when the
DirectBuffer is not acquired.
</para>

</refsect1>

<refsect1>
<title>Return value</title>

<para><function/ggiDBGetNumBuffers/ returns the number of DirectBuffers
available. <ReturnValue/0/ indicates that no DirectBuffers are available.
</para>
<para><function/ggiDBGetBuffer/ returns a pointer to a DirectBuffer
structure.
</para>
</refsect1>

<refsect1>
<title>Examples</title>

<example>
<title>How to obtain a DirectBuffer</title>
<programlisting>

ggi_visual_t	vis;
ggi_mode	mode;
int		i;

/* Framebuffer info */
unsigned char *fbptr[2];
int stride[2];
int numbufs;

mode.frames = 2;	/* Double-buffering */
mode.visible.x = 640;	/* Screen res */
mode.visible.y = 480;
mode.virt.x = GGI_AUTO;	/* Any virtual resolution.  Will usually be set
mode.virt.y = GGI_AUTO;	   to be the same as visible but some targets may
			   have restrictions on virtual size. */
mode.graphtype = GT_8BIT;		/* Depend on 8-bit palette. */
mode.dpp.x = mode.dpp.y = GGI_AUTO;	/* Always 1x1 but we don't care. */

if(ggiInit())
{
	/* Failed to initialize library. Bomb out. */
}

vis = ggiOpen(NULL);
if(!vis)
{
	/* Opening default visual failed, quit. */
}

if(ggiSetMode(vis, &amp;mode))
{
	/* Set mode has failed, should check if suggested mode
	   is o.k. for us, and try the call again. */
}

numbufs = ggiDBGetNumBuffers(vis);

for(i = 0; i < numbufs; i++)
{
	ggi_directbuffer *db;
	int frameno;

	db = ggiDBGetBuffer(vis, i);

	if(!(db->type & GGI_DB_SIMPLE_PLB))
	{
<replaceable>
		/* We don't handle anything but simple pixel-linear buffers.
		   Fall back to ggiPutBox() or something. */
		continue;
</>
	}

	frameno = db->frame;

	if(readptr[frameno] != NULL &&
		(db->buffer.plb.pixelformat->flags & GGI_PF_REVERSE_ENDIAN))
	{
		<replaceable>continue;</replaceable>
	}

	fbptr[frameno] = db->write;	/* read == write for simple plbs */

	/* Stride of framebuffer (in bytes). */
	stride[frameno] = db->buffer.plb.stride;

	<replaceable>/* Check pixel format, be portable.... */</>

</programlisting>
</example>

</refsect1>
</refentry>


