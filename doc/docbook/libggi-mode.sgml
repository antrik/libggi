<chapter id="libggi-mode">
<title/Mode management/

<para>
A mode describes the graphical characteristics of a visual, such as its
visible and virtual dimensions in pixels, and the number of colors.
After opening the visual, you must set a mode before you can do anything
useful with it, such as drawing.
</para>

<para>
A mode in LibGGI is defined by the following in
<filename>ggi/ggi.h</filename>:

<programlisting format="linespecific">
typedef struct { sint16   x, y; } ggi_coord;

typedef struct          /* requested by user and changed by driver	*/
{
        uint32          frames;         /* frames needed                */
        ggi_coord       visible;        /* vis. pixels, may change slightly */
        ggi_coord       virt;           /* virtual pixels, may change   */
        ggi_coord       size;           /* size of visible in mm        */
        ggi_graphtype   graphtype;      /* which mode ?                 */
        ggi_coord       dpp;            /* dots per pixel               */
} ggi_mode;
</programlisting>
</para>

<para>
You usually don't need to manipulate this structure yourself, if you
want to set a mode, but it is necessary if you want to find out the mode
actually being set.
</para>

<variablelist>

<varlistentry>
<term><structname/ggi_coord/</term>
<listitem><para>
<structname/ggi_coord/ represents any 2D coordinate or dimension as
<structfield/x/,<structfield/y/ pixels.
</para></listitem>
</varlistentry>

<varlistentry id="ggi-mode-frames">
<term><structfield/frames/</term>
<listitem>
<para>
Use of <link linkend="frames">multiple buffering</link> is specified in
the <structfield/frames/ member of the <structname/ggi_mode/ struct, as
the number of screen buffers needed.
</para>
</listitem>
</varlistentry>


<varlistentry id="ggi-mode-visible">
<term><structfield/visible/</term>
<listitem>
<para>
The visible area is the subset of the virtual area that is visible to
the user.  <structfield/visible/ specifies the size of this area or the
screen resolution.  
</para>
</listitem>
</varlistentry>

<varlistentry id="ggi-mode-virtual">
<term><structfield/virtual/</term>
<listitem>
<para>
The virtual area is the available drawing area of a visual.
<structfield/virtual/ specifies the size of this area for each frame.
(If all of the drawing area is to be visible on the screen, then
<structfield/visible/ is equal to <structfield/virtual/.)
</para>
</listitem>
</varlistentry>

<varlistentry id="ggi-mode-dpp">
<term><structfield/dpp/</term>
<listitem><para>
<structfield/dpp/ specifies the number of dots per pixel.  For graphic
modes, it is 1x1 by definition.  In text modes, it represents the font
size.
</para></listitem>
</varlistentry>

</variablelist>

<para>
The value of <symbol/GGI_AUTO/ may also be set to any of these fields, 
except <structfield/graphtype/ which may be set to <symbol/GT_AUTO/,
to indicate to the mode-setting and mode-checking functions to recommend
a real value to the LibGGI application.
</para>



<sect1 id="ggi-graphtype">
<title><type/ggi_graphtype/</title>

<para>
<type/ggi_graphtype/ specifies the graphic type. 
There are four sets of information, packed into <type/ggi_graphtype/
using the indicated macros.
</para>

<variablelist>

<varlistentry>
<term><property/depth/</term>
<listitem>
<para>
Number of significant bits (i.e. those that represent the actual color
or some other property of the <link linkend="pixel"/pixel/)
</para>

<para>
Macros: <literal/GT_DEPTH(gt)/, <literal/GT_SETDEPTH(gt,depth)/
</para>

</listitem>
</varlistentry>



<varlistentry>
<term><property/size/</term>
<listitem>

<para>
Number of physical bits per pixel, or its access size.  Bits that are
not significant bits (whose number is specified by <property/depth/
above) are padding.
</para>

<para>
Macros: <literal/GT_SIZE(gt)/, <literal/GT_SETSIZE(gt,size)/
</para>

</listitem>
</varlistentry>

<varlistentry>
<term><property/scheme/</term>

<listitem><para>
One of:

<variablelist>

<varlistentry>
<term><symbol/GT_TEXT/</term>
<listitem><para/text modes/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_TRUECOLOR/</term>
<listitem><para/pixel is a direct RGB value/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_GREYSCALE/</term>
<listitem><para/no color (!!!)/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_PALETTE/</term>
<listitem><para/each pixel is an index to a colormap/</listitem>
</varlistentry>

</variablelist></para>

<para>
Macros: <literal/GT_SCHEME(gt)/, <literal/GT_SETSCHEME(gt,subscheme)/
</para>

</listitem>
</varlistentry>

<varlistentry>
<term><property/subscheme/</term>
<listitem><para>
Miscellaneous information about the pixel.  Any of 
the following flags are bitwise-or'd together:

<variablelist>

<varlistentry>
<term><symbol/GT_SUB_REVERSE_ENDIAN/</term>
<listitem><para>
This is only relevant for modes where a bitfield (such as the red,
green or blue component of pixels) crosses a byte boundary. For
example the green component in common 15- and 16-bit modes does
this.  This flags means that after composing a pixel according to
the masks/shifts in <structname/ggi_pixelformat/ the pixel should
be byteswapped.
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_SUB_HIGHBIT_RIGHT/</term>
<listitem><para>
This is only relevant for modes where more than one pixel is contained
in each byte and means that the high bit/bits corresponds to the
rightmost pixel.
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_SUB_PACKED_GETPUT/</term>
<listitem><para>
Normally ggiGet/Put* buffers use <literal/((GT_SIZE(gt)+7)&amp;(~7))/ bits
per pixel. This flag requests that they use exactly
<literal/GT_SIZE(gt)/ bits per pixel instead. Thus it's only relevant
for modes where the pixelsize is not a multiple of 8 bits.
</para></listitem>
</varlistentry>

</variablelist></para>

<para>
Macros: <literal/GT_SUBSCHEME(gt)/, <literal/GT_SETSUBSCHEME(gt,subscheme)/
</para>

</listitem>
</varlistentry>

</variablelist>


<para>
Applications can set any of these fields to GT_AUTO when setting or
checking a mode to get a recommended value.
</para>

<para>
There are also macros which are aliases for some common <type/ggi_graphtype/s:

<variablelist>

<varlistentry>
<term><symbol/GT_AUTO/</term>
<listitem><para>
Equivalent to <symbol/GGI_AUTO/ for graphic types.  It indicates that
any value may be taken. 
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_TEXT16/</term>
<term><symbol/GT_TEXT32/</term>
<listitem>
<para/Text modes with word- and longword-aligned characters and attributes/
</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_1BIT/</term>
<term><symbol/GT_4BIT/</term>
<term><symbol/GT_8BIT/</term>
<listitem><para/Palettized modes with respective number of bits per
pixel/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_15BIT/</term>
<term><symbol/GT_16BIT/</term>
<listitem><para>
Truecolor modes with an access size of 16 bits.
<symbol/GT_15BIT/ uses 5 bits for each color component,
while <symbol/GT_16BIT/ uses an additional 1 bit for green.
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_24BIT/</term>
<term><symbol/GT_32BIT/</term>
<listitem><para>
Truecolor modes with the a depth of 24 bits.  <symbol/GT_24BIT/ uses an
access size of 24 bits while <symbol/GT_32BIT/ uses an access size of 32
bits.
</para></listitem>
</varlistentry>

</variablelist>
</para>

</sect1>

<sect1 id="ggi-auto">
<title/GGI_AUTO replacement recommendations/

<para>
When <symbol/GGI_AUTO/ is encountered in a parameter, it is replaced
with corresponding values specified by <envar>GGI_DEFMODE</envar> variable.
</para>

<para>
If the corresponding value is not found in <envar>GGI_DEFMODE</envar>
or that value is also <symbol/GGI_AUTO/, then it is up to the driver to
select a reasonable value <link linkend="mode-negotiation">
satisfying as many of the given contraints</link> as 
possible.  The following are some recommendations:

<itemizedlist>

<listitem><para>
If a visible size is given but no virtual, the lowest reasonable (taking
alignment and accelleration constraints into account) should be used.
</para></listitem>

<listitem><para>
If either visible <replaceable/x/ or <replaceable/y/ is given, the other
one should give a <replaceable/x//<replaceable/y/ ratio close to that of
the screen size, normally about 4/3.
</para></listitem>

<listitem><para>
If a virtual size is given but no visible size, the highest possible
visible size is selected.
</para></listitem>

<listitem><para>
If no size is given, the driver uses some builtin default.
</para></listitem>

<listitem><para>
If the graphtype is unspecified, the highest possible graphtype that
meets the geometry constraints is set or suggested.
</para></listitem>

<listitem><para>
<structfield/dpp.x/ and <structfield/dpp.y/ will be 1 for graphics. For
text modes the largest possible <structfield/dpp.x/ and
<structfield/dpp.y/ (the most fine-grained font) should be used.
</para></listitem>

<listitem>
<para><structfield/frames/ will be 1 if not specified. 
</para></listitem>

</itemizedlist>
</para>

<note><para>
The rules above are only <emphasis/recommendations/ (which are hoped to
best capture user expectations) to the driver implementer and in no way
guaranteed. 
</para></note>

</sect1>



<sect1 id="mode-functions">
<title>API functions</title>

<refentry id="ggiCheckMode">

<refmeta>
<refentrytitle><function/ggiCheckMode/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiCheckMode/
<refname/ggiCheckTextMode/
<refname/ggiCheckGraphMode/
<refname/ggiCheckSimpleMode/
<refpurpose>Check or negotiate a text/graphics mode on a visual</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisinfo>

<funcprototype>
<funcdef>int <function/ggiCheckMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
ggi_mode *<parameter/tm/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiCheckTextMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/visual/, 
int <parameter/cols/, int <parameter/rows/, 
int <parameter/vcols/, int <parameter/vrows/, 
int <parameter/fontx/, int <parameter/fonty/, 
ggi_mode *<parameter/suggested_mode/, <replaceable/.../
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiCheckGraphMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/visual/, 
int <parameter/x/, int <parameter/y/, 
int <parameter/xv/, int <parameter/yv/, 
ggi_graphtype <parameter/type/, 
ggi_mode *<parameter/suggested_mode/, <replaceable/.../
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiCheckSimpleMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/visual/, 
int <parameter/x/, int <parameter/y/, 
int <parameter/frames/, 
ggi_graphtype <parameter/type/, 
ggi_mode *<parameter/suggested_mode/
</paramdef>
</funcprototype>

</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiCheckMode/ checks whether or not the given mode will work
on the visual.  If it does not work, it will modify the values of passed
<structname/ggi_mode/ structure so that the mode works.  This mode
negotiation allows the application to discover modes that are both
supported by the visual and suitable to the application.
</para>

<para>
<function/ggiCheckTextMode/ checks whether the text mode with the given
visible and virtual dimensions and the font size is supported.
</para>

<para>
<function/ggiCheckGraphMode/ checks whether the graphics mode with the
given visible and virtual dimensions and type is supported.
</para>

<para>
<function/ggiCheckSimpleMode/ checks wheter the graphics mode with the
given visible dimensions, type, and number of buffers is supported.
This is used in lieu of <function/ggiCheckGraphMode/ if multiple
buffering is desired.
</para>

<para>
For <function/ggiCheckTextMode/, <function/ggiCheckGraphMode/ and
<function/ggiCheckSimpleMode/, <parameter/suggested_mode/ is either
<symbol/NULL/ or a pointer to a <structname/ggi_mode/ which will be
filled in with the negotiated mode parameters.  
</para>


</refsect1>

<refsect1>
<title/Return value/

<para>
For <function/ggiCheckTextMode/ and <function/ggiCheckGraphMode/, a
return of <ReturnValue/0/ means that the corresponding set mode call for
this mode would succeed. Otherwise, the mode given cannot be set. In
this case, <parameter/suggested_mode/ is changed to the suggested mode.
</para>

<para>
If the only modifications made to the structure is replacing
<symbol/GGI_AUTO/ or <symbol/GT_AUTO/ value, the functions return
success.
</para>

</refsect1>

<refsect1 id="mode-negotiation">
<title/Rules for mode negotiation/

<para>
First, if <symbol/GGI_AUTO/ (or <symbol/GT_AUTO/ for the graphtype) is
specified for any of the members of <parameter/*tm/, these are filled in
with the recommended values.  The values could be to a maximum,
preferred, or <envar/GGI_DEFMODE/ resolution, and will be compatible
with any other constraints.  
</para>

<para>
An application that does not care about a specific paramater should
always specify <symbol/GGI_AUTO/ or <symbol/GT_AUTO/ for it.
</para>

<para>
The resulting mode is guaranteed to be valid; if not, the application
can assume that it cannot set any mode on the given visual and give up.
</para>

<para>
The suggested mode is derived as follows:

<itemizedlist>

<listitem>
<para>
Resolutions are always adjusted <emphasis/up/. If you want the
next lower, start out at 1x1 (or somewhere else reasonable) and jump up
the ladder.
</para>

<para>
Only if the maximum resolution would be exceeded, resolutions are
adjusted <emphasis>down</emphasis> to the maximum.
</para>

<para>
The above applies to visible and virtual size. If there is interference
between them, the visible size is satified first if possible, then the
virtual size.
</para>

<para>
The adjustment of one value do not normally affect other values. For
example, if (visible) 320x100 (virtual 320x200) is requested, the
visible size may be adjusted to 320x200, but virtual size will be left
alone. Of course, if the virtual size becomes less than visible size,
then it will be adjusted as well. 
</para>
</listitem>

<listitem>
<para>
Font sizes are handled the other way round: they are adjusted
<emphasis/down/ except when there is nothing below.
</para>
</listitem>

<listitem>
<para>
A specific graphtype is changed only if the card does not support it
<emphasis/at all/.  If the maximum resolution is exceeded, then that is
adjusted down and not the graphtype. This assumes, that if you request
true-color, you really want that and not so badly the resolution you
requested. If this is not the case, you can still retry with another
graphtype or <symbol/GT_AUTO/.
</para>

<para>
If graphtype is changed, it is adjusted in ascending order if possible:
e.g. i.e. 1->4->8->15->16->24/32 bit. So you always get a mode which can
do more than you requested. Only when no better modes are available, the
type is adjusted down.
</para>
</listitem>

</itemizedlist>
</para>
</refsect1>


<refsect1>
<title>Examples</title>

<example>
<title>Try a 320x200x8 mode</title>
<programlisting>
err = ggiCheckGraphMode(vis, 320, 200, GGI_AUTO, GGI_AUTO, GT_8BIT, 
                        &amp;sug_mode, NULL);
if(err) {
        <replaceable>/* Check if returned mode is ok... */</replaceable>
}
else {
        ggiSetMode(&amp;sug_mode);
}
</programlisting>
</example>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist TYPE=inline>
<member><xref linkend="ggiOpen"></member>
<member><xref linkend="ggiSetMode"></member>
</simplelist>

</refsect1>

</refentry>





<refentry ID="ggiSetMode">

<refmeta>
<refentrytitle><function/ggiSetMode/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiSetMode/
<refname/ggiSetTextMode/
<refname/ggiSetGraphMode/
<refname/ggiSetSimpleMode/
<refname/ggiGetMode/
<refpurpose>Set or get a mode on a visual</refpurpose>
</refnamediv>

<refsynopsisdiv><funcsynopsis>
<funcsynopsisinfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisinfo>

<funcprototype>
<funcdef>int <function/ggiSetMode/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, ggi_mode *<parameter/tm/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiSetTextMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/visual/, 
int <parameter/cols/, int <parameter/rows/, 
int <parameter/vcols/, int <parameter/vrows/, 
int <parameter/fontx/, int <parameter/fonty/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiSetGraphMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/visual/, 
int <parameter/x/, int <parameter/y/, 
int <parameter/xv/, int <parameter/yv/, 
ggi_graphtype <parameter/type/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiSetSimpleMode/</funcdef>
<paramdef>
ggi_visual_t <parameter/visual/,
int <parameter/x/, int <parameter/y/, 
int <parameter/frames/, 
ggi_graphtype <parameter/type/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiGetMode/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, ggi_mode *<parameter/tm/</paramdef>
</funcprototype>

</funcsynopsis></refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiSetMode/ sets any mode (text or graphics).
It also performs mode negotiation like <function/ggiCheckMode/, but if
any non-<symbol/GGI_AUTO//<symbol/GT_AUTO/ parameters are changed from
the original mode, the new mode will not be silently set.
</para>

<para>
<function/ggiSetTextMode/, 
<function/ggiSetGraphMode/, 
<function/ggiSetSimpleMode/ are convenient versions of
<function/ggiSetMode/ that take the mode paramters as integer arguments
rather than as a <structname/ggi_mode/ struct that the application has
to fill out.  Otherwise, they are functionally equivalent to
<function/ggiSetMode/ function, and the same mode-setting semantics
apply, except the changed <structname/ggi_mode/ cannot be seen.
</para>

<para>
<function/ggiGetMode/ fills out the passed <structname/ggi_mode/ with
the parameters of the current mode of the visual.
</para>

</refsect1>

<refsect1>
<title>Return value</title>

<para>
The mode setting functions return <ReturnValue/0/ if the mode is set
successfully, otherwise an error code.
</para>

<comment>
Looking at the code, ggiGetMode doesn't just return error if there is no
mode set, but does an ASSERT ! Should this be changed ?
Also we don't need ggiGetMode in vis->opdisplay, do we?
</comment>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist TYPE=inline>
<member><xref linkEnd="ggiOpen"></member>
<member><xref linkEnd="ggiCheckMode"></member>
</simplelist>

</refsect1>
</refentry>


<refentry id="ggiParseMode">

<refmeta>
<refentrytitle><function/ggiParseMode/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiParseMode/
<refname/ggiPrintMode/
<refname/ggiSPrintMode/
<refname/ggiFPrintMode/
<refpurpose/Parse and print formatted strings specifying LibGGI modes/
</refnamediv>

<refsynopsisdiv><funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>

<funcprototype>
<funcdef>int <function/ggiParseMode/</funcdef>
<paramdef>const char *<parameter/s/, ggi_mode *<parameter/m/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiPrintMode/</funcdef>
<paramdef>ggi_mode *<parameter/m/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiSPrintMode/</funcdef>
<paramdef>char *<parameter/s/, ggi_mode *<parameter/m/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiFPrintMode/</funcdef>
<paramdef>FILE *<parameter/s/, ggi_mode *<parameter/m/</paramdef>
</funcprototype>

</funcsynopsis></refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<function/ggiParseMode/ parses a string into a <structname/ggi_mode/. 
</para>

<para>
The <function/ggi*PrintMode/ functions print all the members of <structname/ggi_mode/ in a
human-readable form.  <function/ggiSPrintMode/ outputs to a preallocated
string buffer, <function/ggiFPrintMode/ outputs to a stdio <type/FILE/, and
<function/ggiPrintMode/ outputs to standard output.  These functions
correspond to
<citerefentry><refentrytitle><function/sprintf/</refentrytitle><manvolnum/3/</citerefentry>, 
<citerefentry><refentrytitle><function/fprintf/</refentrytitle><manvolnum/3/</citerefentry>, 
<citerefentry><refentrytitle><function/printf/</refentrytitle><manvolnum/3/</citerefentry>, 
respectively.
</para>

<para>
The format of the string used by these functions is exactly the same as
the one used in the <link linkend="GGI-DEFMODE"><envar/GGI_DEFMODE/</link>
environment variable.
</para>

</refsect1>

<refsect1>
<title>Return value</title>

<para>
<function/ggiParseMode/ returns:

<variablelist>
<varlistentry>
<term><ReturnValue/0/</term>
<listitem>
<para>on success, i.e. the string was correct.
However, errors involving <symbol/GT_*/, position
information, or mismatched brackets do not make it fail;
these errors are simply ignored.</para>
</listitem>
</varlistentry>
<varlistentry>
<term><ReturnValue><0</ReturnValue></term>
<listitem><para>
if there is text that can not be parsed.
This text is printed to stderr.
All parameters parsed so far are written into <parameter/m/.</para>
</listitem>
</varlistentry>

</variablelist>
</para>

<para>
So <parameter/m/ contains all parameters that have been successfully parsed.
For most applications there will be no need for testing
<function/ggiParseMode/ for failure.
</para>
</refsect1>

</refentry>
</sect1>
</chapter>


