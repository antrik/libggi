<chapter id="libggi-mode">
<title/Mode management/

<para>
A mode describes the graphical characteristics of a visual, such as its
visible and virtual dimensions in pixels, and the number of colors.
After opening the visual, you must set a mode before you can do anything
useful with it, such as drawing.
</para>

<para>
A mode in LibGGI is defined by the following in
<filename>ggi/ggi.h</filename>:

<programlisting format="linespecific">
typedef struct { sint16   x, y; } ggi_coord;

typedef struct          /* requested by user and changed by driver	*/
{
        uint32          frames;         /* frames needed                */
        ggi_coord       visible;        /* vis. pixels, may change slightly */
        ggi_coord       virt;           /* virtual pixels, may change   */
        ggi_coord       size;           /* size of visible in mm        */
        ggi_graphtype   graphtype;      /* which mode ?                 */
        ggi_coord       dpp;            /* dots per pixel               */
} ggi_mode;
</programlisting>
</para>

<para>
You usually don't need to manipulate this structure yourself, if you
want to set a mode, but it is necessary if you want to find out the mode
actually being set.
</para>

<variablelist>

<varlistentry>
<term><structname/ggi_coord/</term>
<listitem><para>
<structname/ggi_coord/ represents any 2D coordinate or dimension as
<structfield/x/,<structfield/y/ pixels.
</para></listitem>
</varlistentry>

<varlistentry id="ggi-mode-frames">
<term><structfield/frames/</term>
<listitem>
<para>
Use of <link linkend="frames">multiple buffering</link> is specified in
the <structfield/frames/ member of the <structname/ggi_mode/ struct, as
the number of screen buffers needed.
</para>
</listitem>
</varlistentry>


<varlistentry id="ggi-mode-visible">
<term><structfield/visible/</term>
<listitem>
<para>
The visible area is the subset of the virtual area that is visible to
the user.  <structfield/visible/ specifies the size of this area or the
screen resolution.  
</para>
</listitem>
</varlistentry>

<varlistentry id="ggi-mode-virtual">
<term><structfield/virtual/</term>
<listitem>
<para>
The virtual area is the available drawing area of a visual.
<structfield/virtual/ specifies the size of this area for each frame.
(If all of the drawing area is to be visible on the screen, then
<structfield/visible/ is equal to <structfield/virtual/.)
</para>
</listitem>
</varlistentry>

<varlistentry id="ggi-mode-dpp">
<term><structfield/dpp/</term>
<listitem><para>
<structfield/dpp/ specifies the number of dots per pixel.  For graphic
modes, it is 1x1 by definition.  In text modes, it represents the font
size.
</para></listitem>
</varlistentry>

</variablelist>

<para>
The value of <symbol/GGI_AUTO/ may also be set to any of these fields, 
except <structfield/graphtype/ which may be set to <symbol/GT_AUTO/,
to indicate to the mode-setting and mode-checking functions to recommend
a real value to the LibGGI application.
</para>



<sect1 id="ggi-graphtype">
<title><type/ggi_graphtype/</title>

<para>
<type/ggi_graphtype/ specifies the graphic type. 
There are four sets of information, packed into <type/ggi_graphtype/
using the indicated macros.
</para>

<variablelist>

<varlistentry>
<term><property/depth/</term>
<listitem>
<para>
Number of significant bits (i.e. those that represent the actual color
or some other property of the <link linkend="pixel"/pixel/)
</para>

<para>
Macros: <literal/GT_DEPTH(gt)/, <literal/GT_SETDEPTH(gt,depth)/
</para>

</listitem>
</varlistentry>



<varlistentry>
<term><property/size/</term>
<listitem>

<para>
Number of physical bits per pixel, or its access size.  Bits that are
not significant bits (whose number is specified by <property/depth/
above) are padding.
</para>

<para>
Macros: <literal/GT_SIZE(gt)/, <literal/GT_SETSIZE(gt,size)/
</para>

</listitem>
</varlistentry>

<varlistentry>
<term><property/scheme/</term>

<listitem><para>
One of:

<variablelist>

<varlistentry>
<term><symbol/GT_TEXT/</term>
<listitem><para/text modes/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_TRUECOLOR/</term>
<listitem><para/pixel is a direct RGB value/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_GREYSCALE/</term>
<listitem><para/no color (!!!)/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_PALETTE/</term>
<listitem><para/each pixel is an index to a colormap/</listitem>
</varlistentry>

</variablelist></para>

<para>
Macros: <literal/GT_SCHEME(gt)/, <literal/GT_SETSCHEME(gt,subscheme)/
</para>

</listitem>
</varlistentry>

<varlistentry>
<term><property/subscheme/</term>
<listitem><para>
Miscellaneous information about the pixel.  Any of 
the following flags are bitwise-or'd together:

<variablelist>

<varlistentry>
<term><symbol/GT_SUB_REVERSE_ENDIAN/</term>
<listitem><para>
This is only relevant for modes where a bitfield (such as the red,
green or blue component of pixels) crosses a byte boundary. For
example the green component in common 15- and 16-bit modes does
this.  This flags means that after composing a pixel according to
the masks/shifts in <structname/ggi_pixelformat/ the pixel should
be byteswapped.
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_SUB_HIGHBIT_RIGHT/</term>
<listitem><para>
This is only relevant for modes where more than one pixel is contained
in each byte and means that the high bit/bits corresponds to the
rightmost pixel.
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_SUB_PACKED_GETPUT/</term>
<listitem><para>
Normally ggiGet/Put* buffers use <literal/((GT_SIZE(gt)+7)&amp;(~7))/ bits
per pixel. This flag requests that they use exactly
<literal/GT_SIZE(gt)/ bits per pixel instead. Thus it's only relevant
for modes where the pixelsize is not a multiple of 8 bits.
</para></listitem>
</varlistentry>

</variablelist></para>

<para>
Macros: <literal/GT_SUBSCHEME(gt)/, <literal/GT_SETSUBSCHEME(gt,subscheme)/
</para>

</listitem>
</varlistentry>

</variablelist>


<para>
Applications can set any of these fields to GT_AUTO when setting or
checking a mode to get a recommended value.
</para>

<para>
There are also macros which are aliases for some common <type/ggi_graphtype/s:

<variablelist>

<varlistentry>
<term><symbol/GT_AUTO/</term>
<listitem><para>
Equivalent to <symbol/GGI_AUTO/ for graphic types.  It indicates that
any value may be taken. 
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_TEXT16/</term>
<term><symbol/GT_TEXT32/</term>
<listitem>
<para/Text modes with word- and longword-aligned characters and attributes/
</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_1BIT/</term>
<term><symbol/GT_4BIT/</term>
<term><symbol/GT_8BIT/</term>
<listitem><para/Palettized modes with respective number of bits per
pixel/</listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_15BIT/</term>
<term><symbol/GT_16BIT/</term>
<listitem><para>
Truecolor modes with an access size of 16 bits.
<symbol/GT_15BIT/ uses 5 bits for each color component,
while <symbol/GT_16BIT/ uses an additional 1 bit for green.
</para></listitem>
</varlistentry>

<varlistentry>
<term><symbol/GT_24BIT/</term>
<term><symbol/GT_32BIT/</term>
<listitem><para>
Truecolor modes with the a depth of 24 bits.  <symbol/GT_24BIT/ uses an
access size of 24 bits while <symbol/GT_32BIT/ uses an access size of 32
bits.
</para></listitem>
</varlistentry>

</variablelist>
</para>

</sect1>

<sect1 id="ggi-auto">
<title/GGI_AUTO replacement recommendations/

<para>
When <symbol/GGI_AUTO/ is encountered in a parameter, it is replaced
with corresponding values specified by <envar>GGI_DEFMODE</envar> variable.
</para>

<para>
If the corresponding value is not found in <envar>GGI_DEFMODE</envar>
or that value is also <symbol/GGI_AUTO/, then it is up to the driver to
select a reasonable value <link linkend="mode-negotiation">
satisfying as many of the given contraints</link> as 
possible.  The following are some recommendations:

<itemizedlist>

<listitem><para>
If a visible size is given but no virtual, the lowest reasonable (taking
alignment and accelleration constraints into account) should be used.
</para></listitem>

<listitem><para>
If either visible <replaceable/x/ or <replaceable/y/ is given, the other
one should give a <replaceable/x//<replaceable/y/ ratio close to that of
the screen size, normally about 4/3.
</para></listitem>

<listitem><para>
If a virtual size is given but no visible size, the highest possible
visible size is selected.
</para></listitem>

<listitem><para>
If no size is given, the driver uses some builtin default.
</para></listitem>

<listitem><para>
If the graphtype is unspecified, the highest possible graphtype that
meets the geometry constraints is set or suggested.
</para></listitem>

<listitem><para>
<structfield/dpp.x/ and <structfield/dpp.y/ will be 1 for graphics. For
text modes the largest possible <structfield/dpp.x/ and
<structfield/dpp.y/ (the most fine-grained font) should be used.
</para></listitem>

<listitem>
<para><structfield/frames/ will be 1 if not specified. 
</para></listitem>

</itemizedlist>
</para>

<note><para>
The rules above are only <emphasis/recommendations/ (which are hoped to
best capture user expectations) to the driver implementer and in no way
guaranteed. 
</para></note>

</sect1>
</chapter>


