<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE reference
  PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<reference id="libggi-api-structures"><title>LibGGI Structures</title>


<refentry id="ref-struct-ggi-mode">
<refmeta>
<refentrytitle><structname>ggi_mode</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_mode</refname>
<refname>ggi_coord</refname>
<refname>ggi_graphtype</refname>
<refpurpose>LibGGI mode description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct { sint16 x, y; } ggi_coord;
</programlisting>

<programlisting>
typedef uint32 ggi_graphtype;
</programlisting>

<programlisting>
typedef struct
{
        sint32          frames;
        ggi_coord       visible;
        ggi_coord       virt;
        ggi_coord       size;
        ggi_graphtype   graphtype;
        ggi_coord       dpp;
} ggi_mode;
</programlisting>

<para>The mode structure describes a visual configuration given by
its size and other graphic properties.
</para>

</refsect1>

<refsect1>
<title>Structure Members</title>

<variablelist>

<varlistentry>
<term><structfield>frames</structfield></term>
<listitem><para>
The number of frames. Some displays have multi-buffer capabilites
(double-buffering, triple-buffering...). See libggi <link
linkend="api-ggisetdisplayframe">frame-related functions</link> for
information on working with multiple frames.
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>visible</structfield></term>
<listitem><para>
The size of the visible area. This is what the user will see.
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>virt</structfield></term>
<listitem><para>
The virtual size of the visual. It can be larger (but not smaller)
than the visible area, in which case only a part of it is displayed.
It is useful for scrolling or backing up portions of screen efficiently.
See <link linkend="api-ggisetorigin"><function>ggi[Set|Get]Origin</function>
functions</link> for more.
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>size</structfield></term>
<listitem><para>???
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>graphtype</structfield></term>
<listitem><para>
It holds information on the type of display.  libggi defines macros to
construct graphtypes values or access individual field.
</para>
   <variablelist>

   <varlistentry>
   <term><structfield>depth</structfield>
   ( <symbol>GT_DEPTH</symbol>(gt), <symbol>GT_SETDEPTH</symbol>(gt,x) )
   </term>
   <listitem>
   <para>
   The number of significant bits holding color
   information.
   </para></listitem>
   </varlistentry>

   <varlistentry>
   <term><structfield>size</structfield>
   ( <symbol>GT_SIZE</symbol>(gt), <symbol>GT_SETSIZE</symbol>(gt,x) )
   </term>
   <listitem>
   <para>
   The actual size (in bits) of a pixel.
   For instance, on a 32 bits X server the pixel size is 32 but the
   depth is only 24 (8bits RGB channels, 8 unused).
   </para></listitem>
   </varlistentry>

   <varlistentry>
   <term><structfield>scheme</structfield>
   ( <symbol>GT_SCHEME</symbol>(gt),
   <symbol>GT_SETSCHEME</symbol>(gt,x) )</term>
   <listitem>
   <para>The following schemes are available :
   </para>

   <simplelist>
   <member><symbol>GT_TEXT</symbol> : text mode only</member>
   <member><symbol>GT_TRUECOLOR</symbol> : </member>
   <member><symbol>GT_GREYSCALE</symbol> : pixels represent level of gray</member>
   <member><symbol>GT_PALETTE</symbol> : pixels are entries in a CLUT (Color Look-Up Table)</member>
   <member><symbol>GT_STATIC_PALETTE</symbol></member>
   <member><symbol>GT_SUBSAMPLE_YUV</symbol></member>
   <member><symbol>GT_SUBSAMPLE_U_YCRBR</symbol></member>
   <member><symbol>GT_SUBSAMPLE_S_YCRBR</symbol></member>
   <member><symbol>GT_NIL</symbol></member>
   </simplelist>

   </listitem>
   </varlistentry>
   
   <varlistentry>
   <term><structfield>subscheme</structfield>
   ( <symbol>GT_SUBSCHEME</symbol>(gt),
   <symbol>GT_SETSUBSCHEME</symbol>(gt,x) )
   </term>
   <listitem>
   <para>????
   </para>

   <simplelist>
   <member><symbol>GT_SUB_REVERSE_ENDIAN</symbol></member>
   <member><symbol>GT_SUB_HIGHBIT_RIGHT</symbol></member>
   <member><symbol>GT_SUB_PACKED_GETPUT</symbol></member>
   </simplelist>

   </listitem>
   </varlistentry>
   
   

   </variablelist>

   <para>
   Graphtypes can be constructed directly or via the
   <symbol>GT_CONSTRUCT</symbol>(depth,scheme,size) macro.
   The following common graphtypes are defined :
   </para>

   <simplelist>
   <member><symbol>GT_TEXT16</symbol></member>
   <member><symbol>GT_TEXT32</symbol></member>
   <member><symbol>GT_1BIT</symbol></member>
   <member><symbol>GT_2BIT</symbol></member>
   <member><symbol>GT_4BIT</symbol></member>
   <member><symbol>GT_8BIT</symbol></member>
   <member><symbol>GT_15BIT</symbol></member>
   <member><symbol>GT_16BIT</symbol></member>
   <member><symbol>GT_24BIT</symbol></member>
   <member><symbol>GT_32BIT</symbol></member>
   <member><symbol>GT_AUTO</symbol></member>
   <member><symbol>GT_INVALID</symbol></member>
   </simplelist>

</listitem>
</varlistentry>


<varlistentry>
<term><structfield>dpp</structfield></term>
<listitem><para>
It stands for dot-per-pixel.
</para></listitem>
</varlistentry>


</variablelist>

<para>When filling a mode structure for setting a visual, any field
can be assigned <symbol>GGI_AUTO</symbol> (<symbol>GT_AUTO</symbol>
for graphtype) if a specific value isn't required.
</para>

</refsect1>


<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggicheckmode"/></member>
<member><xref linkend="api-ggisetmode"/></member>
</simplelist>

</refsect1>

</refentry>



<refentry id="ref-struct-ggi-color">
<refmeta>
<refentrytitle><structname>ggi_color</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_color</refname>
<refname>ggi_pixel</refname>
<refpurpose>LibGGI color description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct { uint16 r,g,b,a; }   ggi_color;
</programlisting>

<programlisting>
typedef uint32   ggi_pixel;
</programlisting>

<para>Colors in ggi are described genericaly through the
display-independent <structname>ggi_color</structname> structure. 16
bit channels are used to ensure sufficient precision most displays.
</para>

<para><type>ggi_pixel</type>s are display-dependent pixel values.
They are used by all GGI drawing primitives for efficiency.
Use <function>ggiMapColor</function> to convert ggi_colors to
ggi_pixels.
</para>

</refsect1>

<refsect1>
<title>Structure members</title>

<para>
<structfield>r</structfield>, <structfield>g</structfield> and
<structfield>b</structfield> correspond respectively to the red, green
and blue channels.  Since libggi does not deal with alpha compositing,
the <structfield>a</structfield>(alpha) field is mainly there for
padding and it is not used by libggi. Setting this value has no effect
in libggi itself, and it will most probably not be unmaped correctly
from <type>ggi_pixel</type>s. However, some extensions might make use
of it, in which case you should refer to their documentation.  </para>

<para>
<type>ggi_pixel</type>s format depends on the actual display and mode.
For those who want to operate directly on pixel values, this format
is describe in the <structname>ggi_pixelformat</structname> structure.
</para>

</refsect1>

<refsect1>
<title>Pixel Arrays</title>

<para>Although individual pixels are kept into 32 bits
<type>ggi_pixel</type>, arrays of pixels, as used in
<function>ggi[Get¦Put]*</function> functions,
<function>ggiPackColors</function> and
<function>ggiUnpackPixels</function>, are stored in the display
specific format, thus packed according to the actual pixel size.  This
size is given by the <symbol>GT_SIZE</symbol> macro for
<type>graphtype</type> or the <structfield>size</structfield> field of
the <structname>ggi_pixelformat</structname> structure.  </para>

<para>The buffers provided to these functions must be big enough
to store or read enough pixels. Although it is safe to use 32 bits
per pixel, the optimum size (in bits) can be calculated by multiplying
the number of pixel by their size. Don't forget to round up to a
multiple of 8 to get the number of bytes.
</para>

<para>If you want to access such buffers directly, do not use
pointer arithmetics with <type>ggi_pixel</type>s.
</para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggimapcolor"/></member>
<member><xref linkend="ref-struct-ggi-mode"/></member>
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>
</simplelist>

</refsect1>

</refentry>


<refentry id="ref-struct-ggi-pixelformat">

<refmeta>
<refentrytitle><structname>ggi_pixelformat</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_pixelformat</refname>
<refpurpose>LibGGI pixel format description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct {
	int		depth;		/* Number of significant bits */
	int		size;		/* Physical size in bits */

	/* 
	 * Simple and common things first :
	 * 
	 * Usage of the mask/shift pairs:
	 * If new_value is the _sizeof(ggi_pixel)*8bit_ value of the thing 
	 * you want to set, you do
	 *
	 * *pointer &amp;= ~???_mask; 		// Mask out old bits 
	 * *pointer |= (new_value>>shift) &amp; ???_mask;
	 * 
	 * The reason to use 32 bit and "downshifting" is alignment
	 * and extensibility. You can easily adjust to other datasizes
	 * with a simple addition ...
	 */
	
	/* Simple colors:
	 */
	ggi_pixel	red_mask;	/* Bitmask of red bits */
	int		red_shift;	/* Shift  for red bits */

	ggi_pixel	green_mask;	/* Bitmask of green bits */
	int		green_shift;	/* Shift  for green bits */

	ggi_pixel	blue_mask;	/* Bitmask of blue bits */
	int		blue_shift;	/* Shift  for blue bits */

	/* A few common attributes :
	 */
	ggi_pixel	alpha_mask;	/* Bitmask of alphachannel bits */
	int		alpha_shift;	/* Shift  for alpha bits */

	ggi_pixel	clut_mask;	/* Bitmask of bits for the clut */
	int		clut_shift;	/* Shift  for bits for the clut*/

	ggi_pixel	fg_mask;	/* Bitmask of foreground color */
	int		fg_shift;	/* Shift  for foreground color */

	ggi_pixel	bg_mask;	/* Bitmask of background color */
	int		bg_shift;	/* Shift  for background color */

	ggi_pixel	texture_mask;	/* Bitmask of the texture (for
					   textmodes - the actual character) */
	int		texture_shift;	/* Shift  for texture */

	/*
	 * Now if this doesn't suffice you might want to parse the following
	 * to find out what each bit does:
	 */

	uint32		bitmeaning[sizeof(ggi_pixel)*8];

	uint32		flags;		/* Pixelformat flags */

	uint32		stdformat;	/* Standard format identifier */
	/* This one has only one use for the usermode application:
	 * To quickly check, if two buffers are identical. If both
	 * stdformats are the same and _NOT_ 0 (which means "WEIRD"),
	 * you may use things like memcpy between them which will have
	 * the desired effect ...
	 */
	
} ggi_pixelformat;
</programlisting>

<programlisting>
/* Pixelformat flags */
#define GGI_PF_REVERSE_ENDIAN	0x01
#define GGI_PF_HIGHBIT_RIGHT	0x02
#define GGI_PF_HAM		0x04
#define GGI_PF_EXTENDED		0x08
</programlisting>

<para>
This structure describes the internal format of pixel values for a visual.
Use the <function>ggiGetPixelFormat</function> function.
</para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggigetpixelformat"/></member>
</simplelist>

</refsect1>

</refentry>

<refentry id="ref-struct-ggi-directbuffer">

<refmeta>
<refentrytitle><structname>ggi_directbuffer</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_directbuffer</refname>
<refname>ggi_pixellinearbuffer</refname>
<refname>ggi_pixelplanarbuffer</refname>
<refname>ggi_samplelinearbuffer</refname>
<refname>ggi_sampleplanarbuffer</refname>

<refpurpose>LibGGI direct buffer structure description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
/* Buffer types */
#define GGI_DB_NORMAL		0x0001  /* "frame" is valid when set */
#define GGI_DB_EXTENDED		0x0002
#define GGI_DB_MULTI_LEFT	0x0004
#define GGI_DB_MULTI_RIGHT	0x0008

/* Flags that may be or'ed with the buffer type */
#define GGI_DB_SIMPLE_PLB	0x01000000
/* GGI_DB_SIMPLE_PLB means that the buffer has the following properties:
      type == GGI_DB_NORMAL
      read == write
      noaccess == 0
      align == 0
      layout == blPixelLinearBuffer
*/
</programlisting>

<programlisting>
typedef struct {
	uint32		type;		/* buffer type */
	int		frame;		/* framenumber (GGI_DB_NORMAL) */
 
	/*	access info	*/
	ggi_resource_t	resource;	/* If non-NULL you must acquire the
					   buffer before using it */
	void		*read;		/* buffer address for reads	*/
	void		*write;		/* buffer address for writes	*/
	unsigned int	page_size;	/* zero for true linear buffers	*/

	uint32		noaccess;	
	/* bitfield. bit x set means you may _not_ access this DB at the
	   width of 2^x bytes. Usually 0, but _check_ it. */

	uint32		align;
	/* bitfield. bit x set means you may only access this DB at the
	   width of 2^x bytes, when the access is aligned to a multiple
	   of 2^x. Note that bit 0 is a bit bogus here, but it should
	   be always 0, as then ((noaccess|align)==0) is a quick check
	   for "no restrictions". */

	ggi_bufferlayout	layout;

	/* The actual buffer info. Depends on layout. */
	union {
		ggi_pixellinearbuffer plb;
		ggi_pixelplanarbuffer plan;
		ggi_samplelinearbuffer slb;
		ggi_sampleplanarbuffer splan;
		void *extended;
	} buffer;
} ggi_directbuffer;
</programlisting>

<para>The <structname>ggi_directbuffer</structname> structure contains
information on target-dependent buffers to allow applications to
access them directly.  </para>

</refsect1>

<refsect1>
<title>Structure Members</title>

<variablelist>
<varlistentry>
<term><structfield>frame</structfield></term>
<listitem>
<para>is the frame number as used in multiple buffering.  Note that each
frame can export more than one DirectBuffer.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>layout</structfield></term>
<listitem>
<para>is an enumeration specifying whether the buffer is
pixel-linear, planar, etc.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>buffer</structfield></term>
<listitem>
<para>is a union of all buffer info.  Check the
<structfield>layout</structfield> member to see which member of use.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect1>

<refsect1>
<title>Buffer layouts</title>

<programlisting>
typedef enum {
	blPixelLinearBuffer,
	blPixelPlanarBuffer,
	blExtended,
	blSampleLinearBuffer,
	blSamplePlanarBuffer,

	blLastBufferLayout
} ggi_bufferlayout;

typedef struct {
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixellinearbuffer;

typedef struct {
	int		next_line;	/* bytes until next line	*/
	int		next_plane;	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixelplanarbuffer;

typedef struct {
	int		num_pixels;	/* how many pixelformats	*/
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_samplelinearbuffer;

typedef struct {
	int		next_line[3];	/* bytes until next line	*/
	int		next_plane[3];	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_sampleplanarbuffer;
</programlisting>

</refsect1>

<refsect1>
<title>See Also</title>
<simplelist type="inline">
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>
<member><xref linkend="api-ggidbgetbuffer"/></member>
</simplelist>
</refsect1>

</refentry>

</reference>
