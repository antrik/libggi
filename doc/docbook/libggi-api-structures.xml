<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE reference
  PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<reference id="libggi-api-structures"><title>LibGGI API Structures</title>
<refentry id="ref-struct-ggi-pixelformat">

<refmeta>
<refentrytitle><structname>ggi_pixelformat</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_pixelformat</refname>
<refpurpose>LibGGI pixel format description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct {
	int		depth;		/* Number of significant bits */
	int		size;		/* Physical size in bits */

	/* 
	 * Simple and common things first :
	 * 
	 * Usage of the mask/shift pairs:
	 * If new_value is the _sizeof(ggi_pixel)*8bit_ value of the thing 
	 * you want to set, you do
	 *
	 * *pointer &amp;= ~???_mask; 		// Mask out old bits 
	 * *pointer |= (new_value>>shift) &amp; ???_mask;
	 * 
	 * The reason to use 32 bit and "downshifting" is alignment
	 * and extensibility. You can easily adjust to other datasizes
	 * with a simple addition ...
	 */
	
	/* Simple colors:
	 */
	ggi_pixel	red_mask;	/* Bitmask of red bits */
	int		red_shift;	/* Shift  for red bits */

	ggi_pixel	green_mask;	/* Bitmask of green bits */
	int		green_shift;	/* Shift  for green bits */

	ggi_pixel	blue_mask;	/* Bitmask of blue bits */
	int		blue_shift;	/* Shift  for blue bits */

	/* A few common attributes :
	 */
	ggi_pixel	alpha_mask;	/* Bitmask of alphachannel bits */
	int		alpha_shift;	/* Shift  for alpha bits */

	ggi_pixel	clut_mask;	/* Bitmask of bits for the clut */
	int		clut_shift;	/* Shift  for bits for the clut*/

	ggi_pixel	fg_mask;	/* Bitmask of foreground color */
	int		fg_shift;	/* Shift  for foreground color */

	ggi_pixel	bg_mask;	/* Bitmask of background color */
	int		bg_shift;	/* Shift  for background color */

	ggi_pixel	texture_mask;	/* Bitmask of the texture (for
					   textmodes - the actual character) */
	int		texture_shift;	/* Shift  for texture */

	/*
	 * Now if this doesn't suffice you might want to parse the following
	 * to find out what each bit does:
	 */

	uint32		bitmeaning[sizeof(ggi_pixel)*8];

	uint32		flags;		/* Pixelformat flags */

	uint32		stdformat;	/* Standard format identifier */
	/* This one has only one use for the usermode application:
	 * To quickly check, if two buffers are identical. If both
	 * stdformats are the same and _NOT_ 0 (which means "WEIRD"),
	 * you may use things like memcpy between them which will have
	 * the desired effect ...
	 */
	
} ggi_pixelformat;

/* Pixelformat flags */
#define GGI_PF_REVERSE_ENDIAN	0x01
#define GGI_PF_HIGHBIT_RIGHT	0x02
#define GGI_PF_HAM		0x04
#define GGI_PF_EXTENDED		0x08
</programlisting>

</refsect1>

</refentry>

<refentry id="ref-struct-ggi-directbuffer">

<refmeta>
<refentrytitle><structname>ggi_directbuffer</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_directbuffer</refname>
<refname>ggi_pixellinearbuffer</refname>
<refname>ggi_pixelplanarbuffer</refname>
<refname>ggi_samplelinearbuffer</refname>
<refname>ggi_sampleplanarbuffer</refname>

<refpurpose>LibGGI direct buffer structure description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>The <structname>ggi_directbuffer</structname> structure contains information on
target-dependent buffers to allow applications to access them directly.
</para>

<programlisting>
/* Buffer types */
#define GGI_DB_NORMAL		0x0001  /* "frame" is valid when set */
#define GGI_DB_EXTENDED		0x0002
#define GGI_DB_MULTI_LEFT	0x0004
#define GGI_DB_MULTI_RIGHT	0x0008

/* Flags that may be or'ed with the buffer type */
#define GGI_DB_SIMPLE_PLB	0x01000000
/* GGI_DB_SIMPLE_PLB means that the buffer has the following properties:
      type == GGI_DB_NORMAL
      read == write
      noaccess == 0
      align == 0
      layout == blPixelLinearBuffer
*/

typedef struct {
	uint32		type;		/* buffer type */
	int		frame;		/* framenumber (GGI_DB_NORMAL) */
 
	/*	access info	*/
	ggi_resource_t	resource;	/* If non-NULL you must acquire the
					   buffer before using it */
	void		*read;		/* buffer address for reads	*/
	void		*write;		/* buffer address for writes	*/
	unsigned int	page_size;	/* zero for true linear buffers	*/

	uint32		noaccess;	
	/* bitfield. bit x set means you may _not_ access this DB at the
	   width of 2^x bytes. Usually 0, but _check_ it. */

	uint32		align;
	/* bitfield. bit x set means you may only access this DB at the
	   width of 2^x bytes, when the access is aligned to a multiple
	   of 2^x. Note that bit 0 is a bit bogus here, but it should
	   be always 0, as then ((noaccess|align)==0) is a quick check
	   for "no restrictions". */

	ggi_bufferlayout	layout;

	/* The actual buffer info. Depends on layout. */
	union {
		ggi_pixellinearbuffer plb;
		ggi_pixelplanarbuffer plan;
		ggi_samplelinearbuffer slb;
		ggi_sampleplanarbuffer splan;
		void *extended;
	} buffer;
} ggi_directbuffer;
</programlisting>

<variablelist>
<varlistentry>
<term><structfield>frame</structfield></term>
<listitem>
<para>is the frame number as used in multiple buffering.  Note that each
frame can export more than one DirectBuffer.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>layout</structfield></term>
<listitem>
<para>is an enumeration specifying whether the buffer is
pixel-linear, planar, etc.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>buffer</structfield></term>
<listitem>
<para>is a union of all buffer info.  Check the
<structfield>layout</structfield> member to see which member of use.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect1>

<refsect1>
<title>Buffer layouts</title>

<programlisting>
typedef enum {
	blPixelLinearBuffer,
	blPixelPlanarBuffer,
	blExtended,
	blSampleLinearBuffer,
	blSamplePlanarBuffer,

	blLastBufferLayout
} ggi_bufferlayout;

typedef struct {
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixellinearbuffer;

typedef struct {
	int		next_line;	/* bytes until next line	*/
	int		next_plane;	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixelplanarbuffer;

typedef struct {
	int		num_pixels;	/* how many pixelformats	*/
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_samplelinearbuffer;

typedef struct {
	int		next_line[3];	/* bytes until next line	*/
	int		next_plane[3];	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_sampleplanarbuffer;
</programlisting>

</refsect1>

<refsect1>
<title>See Also</title>
<simplelist type="inline">
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>
<member><xref linkend="api-ggidbgetbuffer"/></member>
</simplelist>
</refsect1>

</refentry>

</reference>
