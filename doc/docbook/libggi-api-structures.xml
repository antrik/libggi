<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE reference
  PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<reference id="libggi-api-structures"><title>LibGGI API Structures</title>


<refentry id="ref-struct-ggi-mode">
<refmeta>
<refentrytitle><structname>ggi_mode</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_mode</refname>
<refname>ggi_coord</refname>
<refname>ggi_graphtype</refname>
<refpurpose>LibGGI mode description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct { sint16 x, y; } ggi_coord;
</programlisting>

<programlisting>
typedef uint32 ggi_graphtype;
</programlisting>

<programlisting>
typedef struct
{
        sint32          frames;         /* frames needed                    */
        ggi_coord       visible;        /* vis. pixels, may change slightly */
        ggi_coord       virt;           /* virtual pixels, may change       */
        ggi_coord       size;           /* size of visible in mm            */
        ggi_graphtype   graphtype;      /* which mode ?                     */
        ggi_coord       dpp;            /* dots per pixel                   */
} ggi_mode;
</programlisting>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggicheckmode"/></member>
<member><xref linkend="api-ggisetmode"/></member>
</simplelist>

</refsect1>

</refentry>



<refentry id="ref-struct-ggi-color">
<refmeta>
<refentrytitle><structname>ggi_color</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_color</refname>
<refname>ggi_pixel</refname>
<refpurpose>LibGGI color description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct { uint16 r,g,b,a; }   ggi_color;
</programlisting>

<programlisting>
typedef uint32   ggi_pixel;
</programlisting>

<para>Colors in ggi are described genericaly through this structure.
16 bit channels are used to ensure a sufficient precision for most
displays.
</para>

<para>Note that GGI drawing functions use ggi_pixels instead. Use
<function>ggiMapColor</function> to convert ggi_colors to ggi_pixels.
</para>

<para>
<structfield>r</structfield>, <structfield>g</structfield> and
<structfield>b</structfield> correspond respectively to the red, green
and blue channels.  . The <structfield>a</structfield>(alpha) field is
mainly there for padding and it is not used by libggi. Setting this
value has no effect in libggi itself, and it will most probably not be
unmaped correctly from ggi_pixels. However, some extensions might make
use of it, in which case you should refer to their documentation.
</para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggimapcolor"/></member>
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>

</simplelist>

</refsect1>

</refentry>


<refentry id="ref-struct-ggi-pixelformat">

<refmeta>
<refentrytitle><structname>ggi_pixelformat</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_pixelformat</refname>
<refpurpose>LibGGI pixel format description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
This structure describes the internal format of pixel values for a visual.
</para>

<programlisting>
typedef struct {
	int		depth;		/* Number of significant bits */
	int		size;		/* Physical size in bits */

	/* 
	 * Simple and common things first :
	 * 
	 * Usage of the mask/shift pairs:
	 * If new_value is the _sizeof(ggi_pixel)*8bit_ value of the thing 
	 * you want to set, you do
	 *
	 * *pointer &amp;= ~???_mask; 		// Mask out old bits 
	 * *pointer |= (new_value>>shift) &amp; ???_mask;
	 * 
	 * The reason to use 32 bit and "downshifting" is alignment
	 * and extensibility. You can easily adjust to other datasizes
	 * with a simple addition ...
	 */
	
	/* Simple colors:
	 */
	ggi_pixel	red_mask;	/* Bitmask of red bits */
	int		red_shift;	/* Shift  for red bits */

	ggi_pixel	green_mask;	/* Bitmask of green bits */
	int		green_shift;	/* Shift  for green bits */

	ggi_pixel	blue_mask;	/* Bitmask of blue bits */
	int		blue_shift;	/* Shift  for blue bits */

	/* A few common attributes :
	 */
	ggi_pixel	alpha_mask;	/* Bitmask of alphachannel bits */
	int		alpha_shift;	/* Shift  for alpha bits */

	ggi_pixel	clut_mask;	/* Bitmask of bits for the clut */
	int		clut_shift;	/* Shift  for bits for the clut*/

	ggi_pixel	fg_mask;	/* Bitmask of foreground color */
	int		fg_shift;	/* Shift  for foreground color */

	ggi_pixel	bg_mask;	/* Bitmask of background color */
	int		bg_shift;	/* Shift  for background color */

	ggi_pixel	texture_mask;	/* Bitmask of the texture (for
					   textmodes - the actual character) */
	int		texture_shift;	/* Shift  for texture */

	/*
	 * Now if this doesn't suffice you might want to parse the following
	 * to find out what each bit does:
	 */

	uint32		bitmeaning[sizeof(ggi_pixel)*8];

	uint32		flags;		/* Pixelformat flags */

	uint32		stdformat;	/* Standard format identifier */
	/* This one has only one use for the usermode application:
	 * To quickly check, if two buffers are identical. If both
	 * stdformats are the same and _NOT_ 0 (which means "WEIRD"),
	 * you may use things like memcpy between them which will have
	 * the desired effect ...
	 */
	
} ggi_pixelformat;

/* Pixelformat flags */
#define GGI_PF_REVERSE_ENDIAN	0x01
#define GGI_PF_HIGHBIT_RIGHT	0x02
#define GGI_PF_HAM		0x04
#define GGI_PF_EXTENDED		0x08
</programlisting>

<para>Use the <function>ggiGetPixelFormat</function> function.
</para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggigetpixelformat"/></member>
</simplelist>

</refsect1>

</refentry>

<refentry id="ref-struct-ggi-directbuffer">

<refmeta>
<refentrytitle><structname>ggi_directbuffer</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_directbuffer</refname>
<refname>ggi_pixellinearbuffer</refname>
<refname>ggi_pixelplanarbuffer</refname>
<refname>ggi_samplelinearbuffer</refname>
<refname>ggi_sampleplanarbuffer</refname>

<refpurpose>LibGGI direct buffer structure description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>The <structname>ggi_directbuffer</structname> structure contains
information on target-dependent buffers to allow applications to
access them directly.  </para>

<programlisting>
/* Buffer types */
#define GGI_DB_NORMAL		0x0001  /* "frame" is valid when set */
#define GGI_DB_EXTENDED		0x0002
#define GGI_DB_MULTI_LEFT	0x0004
#define GGI_DB_MULTI_RIGHT	0x0008

/* Flags that may be or'ed with the buffer type */
#define GGI_DB_SIMPLE_PLB	0x01000000
/* GGI_DB_SIMPLE_PLB means that the buffer has the following properties:
      type == GGI_DB_NORMAL
      read == write
      noaccess == 0
      align == 0
      layout == blPixelLinearBuffer
*/

typedef struct {
	uint32		type;		/* buffer type */
	int		frame;		/* framenumber (GGI_DB_NORMAL) */
 
	/*	access info	*/
	ggi_resource_t	resource;	/* If non-NULL you must acquire the
					   buffer before using it */
	void		*read;		/* buffer address for reads	*/
	void		*write;		/* buffer address for writes	*/
	unsigned int	page_size;	/* zero for true linear buffers	*/

	uint32		noaccess;	
	/* bitfield. bit x set means you may _not_ access this DB at the
	   width of 2^x bytes. Usually 0, but _check_ it. */

	uint32		align;
	/* bitfield. bit x set means you may only access this DB at the
	   width of 2^x bytes, when the access is aligned to a multiple
	   of 2^x. Note that bit 0 is a bit bogus here, but it should
	   be always 0, as then ((noaccess|align)==0) is a quick check
	   for "no restrictions". */

	ggi_bufferlayout	layout;

	/* The actual buffer info. Depends on layout. */
	union {
		ggi_pixellinearbuffer plb;
		ggi_pixelplanarbuffer plan;
		ggi_samplelinearbuffer slb;
		ggi_sampleplanarbuffer splan;
		void *extended;
	} buffer;
} ggi_directbuffer;
</programlisting>

<variablelist>
<varlistentry>
<term><structfield>frame</structfield></term>
<listitem>
<para>is the frame number as used in multiple buffering.  Note that each
frame can export more than one DirectBuffer.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>layout</structfield></term>
<listitem>
<para>is an enumeration specifying whether the buffer is
pixel-linear, planar, etc.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>buffer</structfield></term>
<listitem>
<para>is a union of all buffer info.  Check the
<structfield>layout</structfield> member to see which member of use.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect1>

<refsect1>
<title>Buffer layouts</title>

<programlisting>
typedef enum {
	blPixelLinearBuffer,
	blPixelPlanarBuffer,
	blExtended,
	blSampleLinearBuffer,
	blSamplePlanarBuffer,

	blLastBufferLayout
} ggi_bufferlayout;

typedef struct {
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixellinearbuffer;

typedef struct {
	int		next_line;	/* bytes until next line	*/
	int		next_plane;	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixelplanarbuffer;

typedef struct {
	int		num_pixels;	/* how many pixelformats	*/
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_samplelinearbuffer;

typedef struct {
	int		next_line[3];	/* bytes until next line	*/
	int		next_plane[3];	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_sampleplanarbuffer;
</programlisting>

</refsect1>

<refsect1>
<title>See Also</title>
<simplelist type="inline">
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>
<member><xref linkend="api-ggidbgetbuffer"/></member>
</simplelist>
</refsect1>

</refentry>

</reference>
