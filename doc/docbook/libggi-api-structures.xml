<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE reference
  PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
  "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd">
<reference id="libggi-api-structures"><title>LibGGI Structures</title>


<refentry id="ref-struct-ggi-mode">
<refmeta>
<refentrytitle><structname>ggi_mode</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_mode</refname>
<refname>ggi_coord</refname>
<refname>ggi_graphtype</refname>
<refpurpose>LibGGI mode description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct { sint16 x, y; } ggi_coord;
</programlisting>

<programlisting>
typedef uint32 ggi_graphtype;
</programlisting>

<programlisting>
typedef struct
{
        sint32          frames;
        ggi_coord       visible;
        ggi_coord       virt;
        ggi_coord       size;
        ggi_graphtype   graphtype;
        ggi_coord       dpp;
} ggi_mode;
</programlisting>

<para>The mode structure describes a visual configuration given by
its size and other graphic properties.
</para>

</refsect1>

<refsect1>
<title>Structure Members</title>

<variablelist>

<varlistentry>
<term><structfield>frames</structfield></term>
<listitem><para>
The number of frames. Some displays have multi-buffer capabilites
(double-buffering, triple-buffering...). See libggi <link
linkend="api-ggisetdisplayframe">frame-related functions</link> for
information on working with multiple frames.
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>visible</structfield></term>
<listitem><para>
The size of the visible area. This is what the user will see.
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>virt</structfield></term>
<listitem><para>
The virtual size of the visual. It can be larger (but not smaller)
than the visible area, in which case only a part of it is displayed.
It is useful for scrolling or backing up portions of screen efficiently.
See <link linkend="api-ggisetorigin"><function>ggi[Set|Get]Origin</function>
functions</link> for more.
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>size</structfield></term>
<listitem><para>???
</para></listitem>
</varlistentry>

<varlistentry>
<term><structfield>graphtype</structfield></term>
<listitem><para>
It holds information on the type of display.  libggi defines macros to
construct graphtypes values or access individual field.
</para>
   <variablelist>

   <varlistentry>
   <term><structfield>depth</structfield>
   ( <symbol>GT_DEPTH</symbol>(gt), <symbol>GT_SETDEPTH</symbol>(gt,x) )
   </term>
   <listitem>
   <para>
   The number of significant bits holding color
   information.
   </para></listitem>
   </varlistentry>

   <varlistentry>
   <term><structfield>size</structfield>
   ( <symbol>GT_SIZE</symbol>(gt), <symbol>GT_SETSIZE</symbol>(gt,x) )
   </term>
   <listitem>
   <para>
   The actual size (in bits) of a pixel.
   For instance, on a 32 bits X server the pixel size is 32 but the
   depth is only 24 (8bits RGB channels, 8 unused).
   </para></listitem>
   </varlistentry>

   <varlistentry>
   <term><structfield>scheme</structfield>
   ( <symbol>GT_SCHEME</symbol>(gt),
   <symbol>GT_SETSCHEME</symbol>(gt,x) )</term>
   <listitem>
   <para>The following schemes are available :
   </para>

   <simplelist>
   <member><symbol>GT_TEXT</symbol> : text mode only</member>
   <member><symbol>GT_TRUECOLOR</symbol> : </member>
   <member><symbol>GT_GREYSCALE</symbol> : pixels represent level of gray</member>
   <member><symbol>GT_PALETTE</symbol> : pixels are entries in a CLUT (Color Look-Up Table)</member>
   <member><symbol>GT_STATIC_PALETTE</symbol></member>
   <member><symbol>GT_SUBSAMPLE_YUV</symbol></member>
   <member><symbol>GT_SUBSAMPLE_U_YCRBR</symbol></member>
   <member><symbol>GT_SUBSAMPLE_S_YCRBR</symbol></member>
   <member><symbol>GT_NIL</symbol></member>
   </simplelist>

   </listitem>
   </varlistentry>
   
   <varlistentry>
   <term><structfield>subscheme</structfield>
   ( <symbol>GT_SUBSCHEME</symbol>(gt),
   <symbol>GT_SETSUBSCHEME</symbol>(gt,x) )
   </term>
   <listitem>
   <para>????
   </para>

   <simplelist>
   <member><symbol>GT_SUB_REVERSE_ENDIAN</symbol></member>
   <member><symbol>GT_SUB_HIGHBIT_RIGHT</symbol></member>
   <member><symbol>GT_SUB_PACKED_GETPUT</symbol></member>
   </simplelist>

   </listitem>
   </varlistentry>
   
   

   </variablelist>

   <para>
   Graphtypes can be constructed directly or via the
   <symbol>GT_CONSTRUCT</symbol>(depth,scheme,size) macro.
   The following common graphtypes are defined :
   </para>

   <simplelist>
   <member><symbol>GT_TEXT16</symbol></member>
   <member><symbol>GT_TEXT32</symbol></member>
   <member><symbol>GT_1BIT</symbol></member>
   <member><symbol>GT_2BIT</symbol></member>
   <member><symbol>GT_4BIT</symbol></member>
   <member><symbol>GT_8BIT</symbol></member>
   <member><symbol>GT_15BIT</symbol></member>
   <member><symbol>GT_16BIT</symbol></member>
   <member><symbol>GT_24BIT</symbol></member>
   <member><symbol>GT_32BIT</symbol></member>
   <member><symbol>GT_AUTO</symbol></member>
   <member><symbol>GT_INVALID</symbol></member>
   </simplelist>

</listitem>
</varlistentry>


<varlistentry>
<term><structfield>dpp</structfield></term>
<listitem><para>
It stands for dot-per-pixel.
</para></listitem>
</varlistentry>


</variablelist>

<para>When filling a mode structure for setting a visual, any field
can be assigned <symbol>GGI_AUTO</symbol> (<symbol>GT_AUTO</symbol>
for graphtype) if a specific value isn't required.
</para>

</refsect1>


<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggicheckmode"/></member>
<member><xref linkend="api-ggisetmode"/></member>
</simplelist>

</refsect1>

</refentry>



<refentry id="ref-struct-ggi-color">
<refmeta>
<refentrytitle><structname>ggi_color</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_color</refname>
<refname>ggi_pixel</refname>
<refpurpose>LibGGI color description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct { uint16 r,g,b,a; }   ggi_color;
</programlisting>

<programlisting>
typedef uint32   ggi_pixel;
</programlisting>

<para>Colors in ggi are described genericaly through the
display-independent <structname>ggi_color</structname> structure. 16
bit channels are used to ensure sufficient precision most displays.
</para>

<para><type>ggi_pixel</type>s are display-dependent pixel values.
They are used by all GGI drawing primitives for efficiency.
Use <function>ggiMapColor</function> to convert ggi_colors to
ggi_pixels.
</para>

</refsect1>

<refsect1>
<title>Structure members</title>

<para>
<structfield>r</structfield>, <structfield>g</structfield> and
<structfield>b</structfield> correspond respectively to the red, green
and blue channels.  Since libggi does not deal with alpha compositing,
the <structfield>a</structfield>(alpha) field is mainly there for
padding and it is not used by libggi. Setting this value has no effect
in libggi itself, and it will most probably not be unmaped correctly
from <type>ggi_pixel</type>s. However, some extensions might make use
of it, in which case you should refer to their documentation.  </para>

<para>
<type>ggi_pixel</type>s format depends on the actual display and mode.
For those who want to operate directly on pixel values, this format
is describe in the <structname>ggi_pixelformat</structname> structure.
</para>

</refsect1>

<refsect1>
<title>Pixel Arrays</title>

<para>Although individual pixels are kept into 32 bits
<type>ggi_pixel</type>, arrays of pixels, as used in
<function>ggi[Get¦Put]*</function> functions,
<function>ggiPackColors</function> and
<function>ggiUnpackPixels</function>, are stored in the display
specific format, thus packed according to the actual pixel size.  This
size is given by the <symbol>GT_SIZE</symbol> macro for
<type>graphtype</type> or the <structfield>size</structfield> field of
the <structname>ggi_pixelformat</structname> structure.  </para>

<para>The buffers provided to these functions must be big enough
to store or read enough pixels. Although it is safe to use 32 bits
per pixel, the optimum size (in bits) can be calculated by multiplying
the number of pixel by their size. Don't forget to round up to a
multiple of 8 to get the number of bytes.
</para>

<para>If you want to access such buffers directly, do not use
pointer arithmetics with <type>ggi_pixel</type>s.
</para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggimapcolor"/></member>
<member><xref linkend="ref-struct-ggi-mode"/></member>
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>
</simplelist>

</refsect1>

</refentry>


<refentry id="ref-struct-ggi-pixelformat">

<refmeta>
<refentrytitle><structname>ggi_pixelformat</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_pixelformat</refname>
<refpurpose>LibGGI pixel format description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;
</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct {
	int		depth;		/* Number of significant bits */
	int		size;		/* Physical size in bits */

	/* 
	 * Simple and common things first :
	 * 
	 * Usage of the mask/shift pairs:
	 * If new_value is the _sizeof(ggi_pixel)*8bit_ value of the thing 
	 * you want to set, you do
	 *
	 * *pointer &amp;= ~???_mask; 		// Mask out old bits 
	 * *pointer |= (new_value>>shift) &amp; ???_mask;
	 * 
	 * The reason to use 32 bit and "downshifting" is alignment
	 * and extensibility. You can easily adjust to other datasizes
	 * with a simple addition ...
	 */
	
	/* Simple colors:
	 */
	ggi_pixel	red_mask;	/* Bitmask of red bits */
	int		red_shift;	/* Shift  for red bits */

	ggi_pixel	green_mask;	/* Bitmask of green bits */
	int		green_shift;	/* Shift  for green bits */

	ggi_pixel	blue_mask;	/* Bitmask of blue bits */
	int		blue_shift;	/* Shift  for blue bits */

	/* A few common attributes :
	 */
	ggi_pixel	alpha_mask;	/* Bitmask of alphachannel bits */
	int		alpha_shift;	/* Shift  for alpha bits */

	ggi_pixel	clut_mask;	/* Bitmask of bits for the clut */
	int		clut_shift;	/* Shift  for bits for the clut*/

	ggi_pixel	fg_mask;	/* Bitmask of foreground color */
	int		fg_shift;	/* Shift  for foreground color */

	ggi_pixel	bg_mask;	/* Bitmask of background color */
	int		bg_shift;	/* Shift  for background color */

	ggi_pixel	texture_mask;	/* Bitmask of the texture (for
					   textmodes - the actual character) */
	int		texture_shift;	/* Shift  for texture */

	/*
	 * Now if this doesn't suffice you might want to parse the following
	 * to find out what each bit does:
	 */

	uint32		bitmeaning[sizeof(ggi_pixel)*8];

	uint32		flags;		/* Pixelformat flags */

	uint32		stdformat;	/* Standard format identifier */
	/* This one has only one use for the usermode application:
	 * To quickly check, if two buffers are identical. If both
	 * stdformats are the same and _NOT_ 0 (which means "WEIRD"),
	 * you may use things like memcpy between them which will have
	 * the desired effect ...
	 */
	
} ggi_pixelformat;
</programlisting>

<programlisting>
/* Pixelformat flags */
#define GGI_PF_REVERSE_ENDIAN	0x01
#define GGI_PF_HIGHBIT_RIGHT	0x02
#define GGI_PF_HAM		0x04
#define GGI_PF_EXTENDED		0x08
</programlisting>

<para>
This structure describes the internal format of pixel values for a visual.
Use the <function>ggiGetPixelFormat</function> function.
</para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist type="inline">
<member><xref linkend="api-ggigetpixelformat"/></member>
</simplelist>

</refsect1>

</refentry>

<refentry id="ref-struct-ggi-directbuffer">

<refmeta>
<refentrytitle><structname>ggi_directbuffer</structname></refentrytitle>
<manvolnum>9ggi</manvolnum>
<refmiscinfo>GGI</refmiscinfo>
</refmeta>

<refnamediv>
<refname>ggi_directbuffer</refname>
<refname>ggi_pixellinearbuffer</refname>
<refname>ggi_pixelplanarbuffer</refname>
<refname>ggi_samplelinearbuffer</refname>
<refname>ggi_sampleplanarbuffer</refname>

<refpurpose>LibGGI direct buffer structure description</refpurpose>
</refnamediv>

<refsynopsisdiv>
<synopsis>#include &lt;ggi/ggi.h&gt;</synopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<programlisting>
typedef struct {
	uint32		type;
	int		frame;

	ggi_resource_t	resource;

	void		*read;
	void		*write;

	unsigned int	page_size;
	uint32		noaccess;	
	uint32		align;

	ggi_bufferlayout	layout;

	union {
		ggi_pixellinearbuffer plb;
		ggi_pixelplanarbuffer plan;
		ggi_samplelinearbuffer slb;
		ggi_sampleplanarbuffer splan;
		void *extended;
	} buffer;
} ggi_directbuffer;
</programlisting>

<para>The <structname>ggi_directbuffer</structname> structure contains
information on target-dependent buffers to allow applications to
access them directly.  </para>

</refsect1>

<refsect1>
<title>Structure Members</title>

<variablelist>

<varlistentry>
<term><structfield>type</structfield></term>
<listitem>
<programlisting>
/* Buffer types */
#define GGI_DB_NORMAL		0x0001  /* "frame" is valid when set */
#define GGI_DB_EXTENDED		0x0002
#define GGI_DB_MULTI_LEFT	0x0004
#define GGI_DB_MULTI_RIGHT	0x0008

/* Flags that may be or'ed with the buffer type */
#define GGI_DB_SIMPLE_PLB	0x01000000
/* GGI_DB_SIMPLE_PLB means that the buffer has the following properties:
      type == GGI_DB_NORMAL
      read == write
      noaccess == 0
      align == 0
      layout == blPixelLinearBuffer
*/
</programlisting>
</listitem>
</varlistentry>


<varlistentry>
<term><structfield>frame</structfield></term>
<listitem>
<para>is the frame number as used in multiple buffering.  Note that each
frame can export more than one DirectBuffer.</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>resource</structfield></term>
<listitem>
<para>is a pointer to a lowlevel resource. Certain DirectBuffers need
to be explicitly acquired (i.e. locked) before using them
(i.e. accessing their pointers).  Such a situation may arise if the
underlying visual supports mixed acceleration and framebuffer access,
but they cannot occur at the same time.  In that case, LibGGI needs to
be informed when the application is using the framebuffer.
</para>
<para>You can determine whether the DirectBuffer needs to be acquired
by using <function>ggiResourceMustAcquire</function>.
An acquire is done by using <function>ggiResourceAcquire</function>
and it is released by calling <function>ggiResourceRelease</function>.
</para>

</listitem>
</varlistentry>

<varlistentry>
<term><structfield>read</structfield></term>
<term><structfield>write</structfield></term>
<listitem>
<para>are the addresses where the buffer is mapped to the application.
Read and write access to the buffer is done using load and store
instructions of the host CPU. 
Read operations should be performed using the
<structfield>read</structfield> buffer and write operations should be
performed using the <structfield>write</structfield> buffer. These
might be the same, but need not. If they are, read/write may be done to either
buffer. Please note, that either read or write may be
<symbol>NULL</symbol>. These are write-only or read-only buffers,
which might be caused by hardware limitations. Such buffers are not
suited to do Read-Modify-Write operations, so take care.
</para>
<para>Be aware that these fields  may be changed by an acquire, and
that they may be <symbol>NULL</symbol> or invalid when the
DirectBuffer is not acquired.
</para>
</listitem>
</varlistentry>



<varlistentry>
<term><structfield>page_size</structfield></term>
<listitem>
<para>indicates a Paged buffer if not <symbol>0</symbol>.
</para>
<para>
Successive access to addresses <property>addr0</property> and
<property>addr1</property> of either read or write buffers with

<property>addr0</property>/<structfield>page_size</structfield> !=  
<property>addr1</property>/<structfield>page_size</structfield>

may be very expensive compared to successive accesses with

<property>addr0</property>/<structfield>page_size</structfield> == 
<property>addr1</property>/<structfield>page_size</structfield>.
</para>

<para>
On i386 the penalty will be about 1500 cycles plus 4 cycles per
to be remapped. Because of this, block transfer operations might
become very inefficient for paged buffers. If there are two
different buffers provided for read and write operations,
you should do successive reads from one and do successive writes
to the other. If not, it is recommended to copy pagewise into
a temporary buffer and then to copy this temporary buffer
back to screen.
</para>

</listitem>
</varlistentry>

<varlistentry>
<term><structfield>noaccess</structfield></term>
<listitem>
<para>is a bitfield specifying an access restriction.
When bit x is set, you may not access
this DirectBuffer at the width of 2^x bytes. It is usually 0, but
check it.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>align</structfield></term>
<listitem>
<para>is a bitfield specifying another access restriction.
When bit x is set, you may only access this DirectBuffer at the
width of 2^x bytes, when the access is aligned to a multiple
of 2^x. Note that bit 0 is a bit bogus here, but it should
be always 0, as then ((noaccess|align)==0) is a quick check
for "no restrictions".
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>layout</structfield></term>
<listitem>
<para>is an enumeration specifying the buffer adressing scheme.
Possible values are
<symbol>blPixelLinearBuffer</symbol>,
<symbol>blPixelPlanarBuffer</symbol>,
<symbol>blExtended</symbol>, 
<symbol>blSampleLinearBuffer</symbol> and 
<symbol>blSamplePlanarBuffer</symbol>.
See below for their definition.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term><structfield>buffer</structfield></term>
<listitem>
<para>is a union of all buffer info.  Check the
<structfield>layout</structfield> member to see which member of
use.</para>
</listitem>
</varlistentry>
</variablelist>

</refsect1>

<refsect1>
<title>Pixel Linear Buffer</title>

<programlisting>
typedef struct {
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixellinearbuffer;
</programlisting>

<para>
A linear buffer is a region in the application's virtual memory address
space. A pixel with the pixel coordinates
(<replaceable>x</replaceable>,
<replaceable>y</replaceable>) is assigned a pixel number according to
the following formula:
<programlisting>
<property>pixel_number</property> = (<property>origin_y</property> + <property>y</property>) * 
<structfield>stride</structfield> + <property>origin_x</property> + <property>x</property>;
</programlisting>
</para>

<para>
In any case both <property>x</property> and <property>y</property>
must not be negative, and less than the buffer's width and height
respectively. For top-left-origin screen coordinates,
<structfield>stride</structfield> and <property>origin_y</property>
will both be positive. For
bottom-left-origin screen coordinates, <structfield>stride</structfield> and
<property>origin_y</property> will both be negative. This will result
in the correct pixel number with the same formula in both cases. The
pixel number will be used to address the pixel.
</para>

<para>
A certain number of bits is stored per pixel, and this is
indicated in the <structfield>ggi_pixelformat.access</structfield> field.
For some visuals, the buffer might not be in host CPU native format and
swapping operations need to be performed before writes or after reads.
</para>

</refsect1>

<refsect1><title>Pixel Planar Buffer</title>
<programlisting>
typedef struct {
	int		next_line;	/* bytes until next line	*/
	int		next_plane;	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat;	/* format of the pixels		*/
} ggi_pixelplanarbuffer;
</programlisting>
</refsect1>

<refsect1><title>Sample Linear Buffer</title>
<programlisting>
typedef struct {
	int		num_pixels;	/* how many pixelformats	*/
	int		stride;		/* bytes per row		*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_samplelinearbuffer;
</programlisting>
</refsect1>

<refsect1><title>Sample Planar Buffer</title>
<programlisting>
typedef struct {
	int		next_line[3];	/* bytes until next line	*/
	int		next_plane[3];	/* bytes until next plane	*/
	ggi_pixelformat *pixelformat[4];/* format of the pixels		*/
} ggi_sampleplanarbuffer;
</programlisting>
</refsect1>

<refsect1><title>Extended Buffer</title>
<para>?
</para>
</refsect1>

<refsect1>
<title>See Also</title>
<simplelist type="inline">
<member><xref linkend="ref-struct-ggi-pixelformat"/></member>
<member><xref linkend="api-ggidbgetbuffer"/></member>
<member><xref linkend="api-ggiresourceacquire"/></member>
</simplelist>
</refsect1>

</refentry>

</reference>
