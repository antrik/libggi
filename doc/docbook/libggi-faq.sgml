<chapter id="libggi-faq">
<title/Frequently Asked Questions/
<!-- LibGGI FAQ -->
<!-- Used as different parts of GGI documentation. -->

<qandaset>

<qandadiv>
<title/LibGGI general topics/


<!-- ==================================================================== -->
<qandaentry>
<question><para>What is LibGGI?</para></question>

<answer>
<para>
See <link linkend="libggi-intro">the introduction to LibGGI</link>.
</para>

<para>
For a bit of background:
</para>

<para>
LibGGI was originally developed to access the graphics
functionality KGI (the GGI kernel code) had provided. Support for
different types of displays and hardware are provided by
dynamically-loaded mini-libraries.
</para>

<para>Nowadays LibGGI is a very generic piece of software, that will
run on about every platform that has remotely heard of POSIX (ports
to other systems such as Win32 are underway) and on many display
subsystems.</para>

<para>Even if you don't want to deal with something like kernel
drivers, you should consider using LibGGI, as it will give you a
very broad range of supported hardware and platforms.</para>

<para>(Unfortunately, this can't get into some people's minds: you do
<emphasis>not</emphasis> need to patch and recompile a kernel to use
GGI at all!)</para>

</answer>

</qandaentry>



<!-- ==================================================================== -->
<qandaentry>

<question>
<para>Can I reasonably install and run LibGGI?</para>
</question>

<answer>

<para>Yeah &mdash; sure. LibGGI won't hurt &hellip; If you can do graphics with
about anything (X, SVGAlib, Glide) now, then you can with LibGGI.
But your GGI applications will run on all of those without need for
recompiling or anything.</para>

<para>
Of course, to use LibGGI you need LibGGI applications.  For developers,
the API is stable now, so hack away and port your favorite applications to GGI
:)</para>

</answer>
</qandaentry>




<!-- ==================================================================== -->
<qandaentry>
<question><para>If I can, then should I? Why?</para></question>

<answer>
<para>Yes. Why ? See above. I like it, when the same binary pops up as
a window under X or fullscreen from the console (yet without the
risk of console hangs or SUID binaries).</para>

</answer>
</qandaentry>


<!-- ==================================================================== -->
<qandaentry>
<question><para>Is it slow?</para></question>

<answer>
<para>No, wrappers aren't always slow. We took great care to optimize
things, and we actually do support acceleration, where
available.</para>

<para>Or as one our developers puts it: You might want to mention
squake running on svgalib-wrapper running on LibGGI running on X
gives about the same framerate as squake running on SVGAlib
directly on the gfxhw ;)</para>
</answer>

</qandaentry>


<!-- ==================================================================== -->
<qandaentry>
<question><para>What are LibGGI extensions?</para></question>

<answer>
<para>Because LibGGI is designed to be simple, it only provides basic
drawing functions and visual management. Some applications may need
more sophiscated functionality. This is provided by extensions,
which are attached to LibGGI visuals (displays). Extensions have
full access to the internals of LibGGI and may implement advanced
features such as 3D, while using LibGGI's flexible DL system.</para>

</answer>
</qandaentry>

<!-- ==================================================================== -->
<qandaentry>

<question><para>Does DirectBuffer have any relation to Microsoft's
DirectX?</para></question>

<answer>
<para>No. It is simply a term that describes a certain LibGGI feature,
which allows applications to <emphasis/direct/ly use a
(frame)<emphasis/buffer/.</para>
</answer>

</qandaentry>
</qandadiv>



<!-- ==================================================================== -->
<qandadiv>
<title/Building LibGGI source/

<qandaentry>
<question><para>How do I compile the LibGGI code in CVS?</para></question>

<answer>
<para>
The <command>configure</command> scripts and
<filename>Makefile</filename>s are automatically generated using the GNU
autoconf (version &gt;=2.13) and automake (&gt;=1.4) tools.  If you are
building the CVS source, you need to have these tools installed and
create these files by running the <command>autogen.sh</command> script
included in the library directories.
</para>

<para>
The libraries in CVS already come with
the required libtool (&gt;=1.2d) macros, but if you have an
existing libtool, beware that that it could cause conflicts while
configuring. Please try moving your existing libtool installation
first if you encounter such problems.
</para>

<para>For a complete rebuild, you can run the <command>buildall</command>
script in <filename>degas/lib/</filename>, which will automatically
rebuild and reinstall LibGII, LibGGI, and the other libs that are
considered stable.</para>

<para>Alternatively, use our daily snapshots, which will have the
scripts automatically created for you.</para>

</answer>
</qandaentry>


<!-- ==================================================================== -->
<qandaentry>

<question><para>I get <computeroutput/structure has no member named `accel'/ errors
when compiling the LibGGI fbdev target!</para></question>

<answer>
<para>Either you do not have a Linux 2.2.<replaceable/x/ kernel
sources/headers installed or /usr/include/linux points to the
headers for an older kernel.</para>

<para>If the newer kernel headers are available, you can use the
<option>--with-extra-includes=<replaceable/include_path/</option> option to
LibGGI <command>configure</command>, or you can disable compiling the fbdev
target (thus avoiding the errors) by using <command>
--disable-fbdev</command>.</para>
</answer>
</qandaentry>

</qandadiv>

<!-- ==================================================================== -->
<qandadiv>
<title/Programming questions/


<qandaentry>
<question>
<para>How to handle key repeat in games?</para>

<blockquote>
<para>
&hellip;
ship turns as desired.  However, we want constant rotation when the key is
held down, and so we tried the emKeyRepeat event. This even works as
desired, until the key is released, and the result is that the ship keeps
spinning because there are so many emKeyRepeat events in the event queue.
</para>

<para>
What we need is the ship to stop moving as soon as the key is
released...we'd like to be able to simply listen for the emKeyRelease
event and, when it is encountered, flush the queue of all queued
emKeyRepeat elements. However, I didn't see any documentation for
manipulation of the event queue and so I'm at odds with what to do.
</para>
</blockquote>
</question>

<answer>
<para>
There is a better way: 
</para>

<para>
When you get an <symbol/evKeyPress/ event (e.g. for turn left), set a variable
that says "make the ship turn left" and then handle that variable in
your main loop, e.g. <literal/if (turnleft) TurnShipLeft()/.  When you get an
<symbol/evKeyRelease/ event for that key, then clear that variable.
</para>

<para>
Not all targets have repeating keys, and on the ones that do, you can't
rely on either the repeat speed (which could be really slow) or the
delay before repeating.  So using <symbol/evKeyRepeat/ the way you described is
not a good method for games.
</para>
</answer>

</qandaentry>



<!-- ==================================================================== -->
<qandaentry>
<question>
<para>How to copy indexed images to the screen?</para>

<blockquote>
<para>
Hi, I've written a simple PCX image loader
with a "indexed image to ggiPixel-image converter"
looking something like the following:
</para>

<programlisting><![CDATA[
/*************************************************/
ggi_color tempc;
ggi_pixel image[image_size];
for(i=0; i<256; i++)
{
      tempc.r = RGBpalette[i].r<<8;   <-- RGBpalette: RGB-triplets from PCX-file
      tempc.g = RGBpalette[i].g<<8;
      tempc.b = RGBpalette[i].b<<8;
      tempc.a = 0;
      image[i] = ggiMapColor(vis, &tempc);
}
/*************************************************/
]]></programlisting>

<para>
This works fine under X in Hi-Color modes (?x?x16Bpp),
but it seems to slow down to "annoyingly slow" speed
when using GT_8BIT modes with GGI_DISPLAY=palemu or
when running X in 8bpp and "GGI_AUTO mode settings".
Am I doing something wrong or is this a "feature" ??????
</para>

</blockquote>
</question>

<answer>
<para>
The above snippet is just a RGB-image-to-ggiPixel-image converter :)
I assume you actually have an array of indices into the RGBpalette?
</para>

<para>
Note that doing the above in GT_8BIT modes is very slow because ggiMapColor() has
to look up your RGB color in the visual's (default?) palette every time.
</para>

<para>
The obvious way to speed it up is to set the palettized visual's palette
to be the same as the one in your indexed image:

<programlisting><![CDATA[
ggi_visual vis;
ggi_mode ggimode;

/* ... */

if(GT_SCHEME(ggimode.graphtype) == GT_PALETTE) {
        ggi_color ggipalette[256];
        ggi_pixel ggiimage[imagesize];
        ggi_pixelformat *fp;
        int i;

        /* Translate RGBpalette to GGI palette */
        for(i = 0; i<256; i++) {
                p[i].r = RGBpalette[i].r << 8;
                p[i].g = RGBpalette[i].g << 8;
                p[i].b = RGBpalette[i].b << 8;
                p[i].a = 0;
        }
        ggiSetPalette(vis, 256, ggipalette);    /* Check return code! */


        /* Make ggi_pixel operations portable to
           all types of hardware */
        fp = ggiGetPixelFormat(vis);

        /* Translate indexed image to indexed-ggi_pixel-image */
        for(i = 0; i<imagesize; i++) {
                ggiimage[i] = (image[i] >> fp->clut_shift)
                                & fp->clut_mask;
        }
}
else {
        /* Other cases go here */
}
]]></programlisting>
</para>

<para>
The above isn't the most efficiently coded (e.g. could use incrementing
pointers instead of indexing the array every time), but you get the
idea.
</para>

<para>
Note that you can also avoid function call overhead by translating
RGBpalette into a buffer and using ggiPackColors() to map all colors at
once.  The gain may be negligible, but it gives you a packed buffer
which is immediately usable as ggiPutBox, ggiPutHLine, etc. arguments.
(ggi_pixel array values cannot be usually/portably used this way.)
</para>

<para>
Of course you can do the packing yourself as well.  LibGGI provides all
the hardware-specific information you need through ggiGetPixelFormat().
</para>

</answer>
</qandaentry>


<!-- ==================================================================== -->
<qandaentry>
<question>
<para>Why does
<citerefentry><refentrytitle/sleep/<manvolnum/2/</citerefentry>
not work in LibGGI?</para>

<para>
Once the visual is closed the 
<citerefentry><refentrytitle/sleep/<manvolnum/2/</citerefentry>
call works again.
</para>
</question>

<answer>
<para>
<citerefentry><refentrytitle/sleep/<manvolnum/2/</citerefentry>
fails because it is being interrupted by the signals caused by
manual syncing.  The only way I can think of to get around this is to
use <citerefentry><refentrytitle/select/<manvolnum/2/</citerefentry>
or giiEventSelect(), but getting interrupted 20 times per
second doesn't help you much, does it? :(
</para>

<para>
If you really want to sleep, the best way is to simply turn off SYNC
mode (see <xref linkend="ggiSetFlags">).
</para>
</answer>

</qandaentry>

</qandadiv>

</qandaset>

</chapter>

