<chapter id="libggi-color">
<title>Color and palette</title>

<sect1 id="ggi-color">
<title><type/ggi_color/</title>

<para>
The <structname/ggi_color/ struct specifies a RGB color.  It has 16 bit
wide entries for red (<structfield/.r/), green (<structfield/.g/), and
blue (<structfield/.b/) values. It also has an alpha value
(<structfield/.a/) which is unused in LibGGI, but allow LibGGI
extensions to store an alpha value there.
</para>

<para>
Please scale your palette values as necessary.
</para>

</sect1>

<sect1 id="ggi-pixel">
<title><type/ggi_pixel/</title>

<para>
For drawing operations, LibGGI uses a pixelvalue, which is 
the hardware-dependent representation of a <link linkend="pixel"/pixel/.
The pixelvalue is represented by the type <type/ggi_pixel/.
</para>

<para>
A pixelvalue is usually obtained from a <structname/ggi_color/ by 
<link linkend="ggiMapColor"><function/ggiMapColor/</link> or read from
the visual by <link linkend="ggiDrawPixel"><function/ggiGetPixel/</link>.
</para>

<para>
The relationship between a <structname/ggi_color/ and its associated
<type/ggi_pixel/ value does not change unless you change the visual or
the mode or the <link linkend="palette"/palette/ for palettized modes.
</para>

<para>
You can also do calculations with <type/ggi_pixel/ values.  Their format is
defined in <xref linkend="ggi-pixelformat">.
</para>

</sect1>


<chapter id="ggi-pixelformat">
<title><structname/ggi_pixelformat/</title>


<para>
The <structname/ggi_pixelformat/ structure describes the format of a
<type/ggi_pixel/.  An application would use this if it wanted to
directly output pixelvalues, rather than calling <link
linkend="ggiMapColor"><function/ggiMapColor/</link> or 
<function/ggiPackColors/ to convert a
<structname/ggi_color/ to a <type/ggi_pixel/ value.  
</para>

<para>
Other than the parameters of a <type/ggi_graphtype/ that you can
specifically request at mode setting, there is no other way to change
the parameters of <structname/ggi_pixelformat/.  An application must not
assume the presence of any particular pixelformat.  If the application
cannot handle a particular pixelformat, it should fall back on
<function/ggiMapColor/, <function/ggiPackColors/ or 
<link linkend="ggiCrossBlit"><function/ggiCrossBlit/</link>.
</para>

<programlisting>
/* Pixelformat for ggiGet/Put* buffers and pixellinearbuffers */
typedef struct {
        int             depth;          /* Number of significant bits */
        int             size;           /* Physical size in bits */

        /*
         * Simple and common things first :
         *
         * Usage of the mask/shift pairs:
         * If new_value is the _sizeof(ggi_pixel)*8bit_ value of the thing
         * you want to set, you do
         *
         * *pointer &= ~???_mask;               // Mask out old bits
         * *pointer |= (new_value>>shift) & ???_mask;
         *
         * The reason to use 32 bit and "downshifting" is alignment
         * and extensibility. You can easily adjust to other datasizes
         * with a simple addition ...
         */

        /* Simple colors:
         */
        ggi_pixel       red_mask;       /* Bitmask of red bits */
        int             red_shift;      /* Shift  for red bits */

        ggi_pixel       green_mask;     /* Bitmask of green bits */
        int             green_shift;    /* Shift  for green bits */

        ggi_pixel       blue_mask;      /* Bitmask of blue bits */
        int             blue_shift;     /* Shift  for blue bits */

        /* A few common attributes :
         */
        ggi_pixel       alpha_mask;     /* Bitmask of alphachannel bits */
        int             alpha_shift;    /* Shift  for alpha bits */

        ggi_pixel       clut_mask;      /* Bitmask of bits for the clut */
        int             clut_shift;     /* Shift  for bits for the clut*/

        ggi_pixel       fg_mask;        /* Bitmask of foreground color */
        int             fg_shift;       /* Shift  for foreground color */

        ggi_pixel       bg_mask;        /* Bitmask of background color */
        int             bg_shift;       /* Shift  for background color */

        ggi_pixel       texture_mask;   /* Bitmask of the texture (for
                                           textmodes - the actual character)
*/
        int             texture_shift;  /* Shift  for texture */

</programlisting>

<para> 
The above is used to describe a pixel simply.  More detailed information, if
required, can be obtained from the following fields.  See
<filename>ggi/ggi.h</filename> for a listing of bitmeanings.

<programlisting>
        /*
         * Now if this doesn't suffice you might want to parse the following
         * to find out what each bit does:
         */

        uint32          bitmeaning[sizeof(ggi_pixel)*8];

        /* Shall we keep those ?
         */
        uint32          flags;          /* Pixelformat flags */

        uint32          stdformat;      /* Standard format identifier */
        /* This one has only one use for the usermode application:
         * To quickly check, if two buffers are identical. If both
         * stdformats are the same and _NOT_ 0 (which means "WEIRD"),
         * you may use things like memcpy between them which will have
         * the desired effect ...
         */

} ggi_pixelformat;

/* Pixelformat flags */
#define GGI_PF_REVERSE_ENDIAN   0x01
#define GGI_PF_HIGHBIT_RIGHT    0x02
#define GGI_PF_HAM              0x04
#define GGI_PF_EXTENDED         0x08
</programlisting>
</para>

<para>
<structfield/depth/ and <structfield/size/ are same as the depth and access
size information specified in the <type/ggi_graphtype/.
</para>
<para>
<structfield/clut_mask/ is used in GT_PALETTE modes, indicating which bits
correspond to an index to the CLUT (color look-up table).
</para>
<para>
<structfield/fg_mask/, <structfield/bg_mask/, and <structfield/texture_mask/
are for text modes only, indicating the parts of the text-mode character.
</para>

</chapter>


