<chapter id="libggi-color">
<title>Color and palette</title>

<sect1 id="ggi-color">
<title><type/ggi_color/</title>

<para>
The <structname/ggi_color/ struct specifies a RGB color.  It has 16 bit
wide entries for red (<structfield/.r/), green (<structfield/.g/), and
blue (<structfield/.b/) values. It also has an alpha value
(<structfield/.a/) which is unused in LibGGI, but allow LibGGI
extensions to store an alpha value there.
</para>

<para>
Please scale your palette values as necessary.
</para>

</sect1>

<sect1 id="ggi-pixel">
<title><type/ggi_pixel/</title>

<para>
For drawing operations, LibGGI uses a pixelvalue, which is 
the hardware-dependent representation of a <link linkend="pixel"/pixel/.
The pixelvalue is represented by the type <type/ggi_pixel/.
</para>

<para>
A pixelvalue is usually obtained from a <structname/ggi_color/ by 
<link linkend="ggiMapColor"><function/ggiMapColor/</link> or read from
the visual by <link linkend="ggiDrawPixel"><function/ggiGetPixel/</link>.
</para>

<para>
The relationship between a <structname/ggi_color/ and its associated
<type/ggi_pixel/ value does not change unless you change the visual or
the mode or the <link linkend="palette"/palette/ for palettized modes.
</para>

<para>
You can also do calculations with <type/ggi_pixel/ values.  Their format is
defined in <xref linkend="ggi-pixelformat">.
</para>

</sect1>



<sect1 id="color-functions">
<title>API functions</title>

<refentry id="ggiMapColor">

<refmeta>
<refentrytitle><function/ggiMapColor/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiMapColor/
<refname/ggiUnmapPixel/
<refname/ggiPackColors/
<refname/ggiUnpackPixels/
<refpurpose>Convert from ggi_color(s) to ggi_pixel(s) and vice versa
</refpurpose></refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>

<funcprototype>
<funcdef>ggi_pixel <function/ggiMapColor/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/, ggi_color *<parameter/col/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiUnmapPixel/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
ggi_pixel <parameter/pixel/, ggi_color *<parameter/col/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiPackColors/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
void *<parameter/buf/, 
ggi_color *<parameter/cols/, 
int <parameter/len/</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiUnpackPixels/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
void *<parameter/buf/, 
ggi_color *<parameter/cols/, 
int <parameter/len/
</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para><function/ggiMapColor/ gets the pixelvalue for the given color.
</para>
<para><function/ggiUnmapPixel/ gets the color associated with the given
pixelvalue.
</para>
<para>
<function/ggiPackColors/ converts the colors in <parameter/cols/ to 
<link linkend="ggi-pixel"/pixelvalues/ in <parameter/buf/.  
The output from this function is suitable for input to the
<function/ggiPut{HLine,VLine,Box}/ functions.
</para>
<para>
<function/ggiUnpackPixels/ converts the pixelvalues in <parameter/buf/ to
individual elements of <parameter/cols/.  This function maybe used to convert
buffers output by the <function/ggiGet{HLine,VLine,Box}/ functions from the
pixelvalue representation to their actual <link linkend="ggi-color"/colors/.
</para>
<para>
The buffers output from <function/ggiPackColors/ and the input to
<function/ggiUnpackPixels/ are in the same format as the get/put buffers. 
Their format is defined in <structname/ggi_pixelformat/.
</para>

<para>
Try to cache the results of color lookups in your application for
efficiency purposes.
</para>

</refsect1>

<refsect1>
<title>Return value</title>

<para><function/ggiMapColor/ returns a <type/ggi_pixel/.
</para>
<para><function/ggiUnmapPixel/, <function/ggiPackColors/, and
<function/ggiUnpackPixels/ returns <ReturnValue/0/ for OK, otherwise an
error code.
</para>

</refsect1>
</refentry>


<refentry ID="ggiSetPalette">

<refmeta>
<refentrytitle><function/ggiSetPalette/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiSetPalette/
<refname/ggiGetPalette/
<refpurpose>Manipulate the palette of a visual
</refpurpose></refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>

<funcprototype>
<funcdef>int <function/ggiGetPalette/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
int <parameter/s/, 
int <parameter/len/, 
ggi_color *<parameter/cmap/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiSetPalette/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
int <parameter/s/, 
int <parameter/len/, 
ggi_color *<parameter/cmap/
</paramdef>
</funcprototype>

</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
LibGGI visuals in <symbol/GT_PALETTE/ mode maps all pixelvalues to the
corresponding <structname/ggi_color/ entry in the visual's <link
linkend="palette"/palette/.
</para>
<para>
<function/ggiSetPalette/ sets a range of palette values, of length
<parameter/len/, starting at index number <parameter/s/.  The index can be
<symbol/GGI_PALETTE_DONTCARE/ to indicate to indicate that the palette can be
installed anywhere in the CLUT.
This allows optimised use in windowing environments (to minimize color
flashing between windows) and should be used if possible.
</para>
<para>
<function/ggiGetPalette/ copies the specified colors (starting from
<parameter/s/, for <parameter/len/ colors) from the visual's palette to the array
pointed by <parameter/cmap/.
</para>

</refsect1>

<refsect1>
<title>Return value</title>

<para><function/ggiSetPalette/ returns the number of the first entry
changed.  Negative values indicate error (codes).  </para>

<para><function/ggiGetPalette/ returns <ReturnValue/0/ for OK, otherwise
an error code. When called with len=0 this function will not
automatically succeed, but the return code will indicate whether there
is a readable CLUT.  </para>

</refsect1>

<refsect1>
<title>See Also</title>

<simplelist TYPE=inline>
<member>
<xref linkEnd="ggiSetColorfulPalette">
</member>
</simplelist>

</refsect1>

</refentry>


<refentry ID="ggiSetColorfulPalette">
<refmeta>
<refentrytitle><function/ggiSetColorfulPalette/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiSetColorfulPalette/
<refpurpose>Set a palette with a full range of all colors
</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>
<funcprototype>
<funcdef>int <function/ggiSetColorfulPalette/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
LibGGI guarantees that there will be a default palette when a palettized mode is
set.  What this default is, however, is dependent on the visual. 
For example, the X target deliberately avoids setting all colors 
to avoid color-flashing when moving between windows.
</para>

<para>
Applications that want to ensure that they have a full scale of all colors
can call <function/ggiSetColorfulPalette/ after mode set.  This function uses a
smarter color allocation scheme, causing good colors but still minimal
flashing in windowed targets.
</para>

</refsect1>

<refsect1>
<title>Return value</title>

<para><function/ggiSetColorfulPalette/ returns the number of the first entry
changed.  Negative values indicate error (codes).
</para>

</refsect1>

<refsect1>
<title>See Also</title>
<simplelist TYPE=inline>
<member>
<xref linkEnd="ggiSetPalette">
</member>
</simplelist>

</refsect1>
</refentry>


<refentry id="ggiSetGamma">

<refmeta>
<refentrytitle><function/ggiSetGamma/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiSetGammaMap/
<refname/ggiGetGammaMap/
<refname/ggiSetGamma/
<refname/ggiGetGamma/
<refpurpose>Manipulate the gamma maps and the gamma correction of a visual
</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>

<funcprototype>
<funcdef>int <function/ggiSetGammaMap/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
int <parameter/s/, int <parameter/len/, 
ggi_color *<parameter/gammamap/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiGetGammaMap/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
int <parameter/s/, int <parameter/len/, 
ggi_color *<parameter/gammamap/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiSetGamma/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/,
ggi_float <parameter/r/, 
ggi_float <parameter/g/, 
ggi_float <parameter/b/
</paramdef>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiGetGamma/</funcdef>
<paramdef>
ggi_visual_t <parameter/vis/, 
ggi_float *<parameter/r/, 
ggi_float *<parameter/g/, 
ggi_float *<parameter/b/
</paramdef>
</funcprototype>

</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>

<para>
<!-- From Andrew: -->
Some truecolor modes on some hardware can use the DAC's palette to lookup
the values before sending to the monitor.  Generally this is used for gamma
correction by filling the lookup table with a curve, hence the name "gamma
map", but it could be used for other things e.g. special effects in games.
</para>
<para>
<function/ggiSetGammaMap/ and <function/ggiGetGammaMap/ sets or gets the
gamma map, for <parameter/len/ colors starting at <parameter/s/.
</para>
<para>
<function/ggiSetGamma/ and <function/ggiGetGamma/ sets or gets the gamma
correction for the visual.
</para>
</refsect1>

<refsect1>
<title>Return value</title>

<para>All four functions <ReturnValue/0/ for OK, otherwise an
error code. </para>

</refsect1>
</refentry>
</sect1>
</chapter>



<chapter id="ggi-pixelformat">
<title><structname/ggi_pixelformat/</title>


<para>
The <structname/ggi_pixelformat/ structure describes the format of a
<type/ggi_pixel/.  An application would use this if it wanted to
directly output pixelvalues, rather than calling <link
linkend="ggiMapColor"><function/ggiMapColor/</link> or 
<function/ggiPackColors/ to convert a
<structname/ggi_color/ to a <type/ggi_pixel/ value.  
</para>

<para>
Other than the parameters of a <type/ggi_graphtype/ that you can
specifically request at mode setting, there is no other way to change
the parameters of <structname/ggi_pixelformat/.  An application must not
assume the presence of any particular pixelformat.  If the application
cannot handle a particular pixelformat, it should fall back on
<function/ggiMapColor/, <function/ggiPackColors/ or 
<link linkend="ggiCrossBlit"><function/ggiCrossBlit/</link>.
</para>

<programlisting>
/* Pixelformat for ggiGet/Put* buffers and pixellinearbuffers */
typedef struct {
        int             depth;          /* Number of significant bits */
        int             size;           /* Physical size in bits */

        /*
         * Simple and common things first :
         *
         * Usage of the mask/shift pairs:
         * If new_value is the _sizeof(ggi_pixel)*8bit_ value of the thing
         * you want to set, you do
         *
         * *pointer &= ~???_mask;               // Mask out old bits
         * *pointer |= (new_value>>shift) & ???_mask;
         *
         * The reason to use 32 bit and "downshifting" is alignment
         * and extensibility. You can easily adjust to other datasizes
         * with a simple addition ...
         */

        /* Simple colors:
         */
        ggi_pixel       red_mask;       /* Bitmask of red bits */
        int             red_shift;      /* Shift  for red bits */

        ggi_pixel       green_mask;     /* Bitmask of green bits */
        int             green_shift;    /* Shift  for green bits */

        ggi_pixel       blue_mask;      /* Bitmask of blue bits */
        int             blue_shift;     /* Shift  for blue bits */

        /* A few common attributes :
         */
        ggi_pixel       alpha_mask;     /* Bitmask of alphachannel bits */
        int             alpha_shift;    /* Shift  for alpha bits */

        ggi_pixel       clut_mask;      /* Bitmask of bits for the clut */
        int             clut_shift;     /* Shift  for bits for the clut*/

        ggi_pixel       fg_mask;        /* Bitmask of foreground color */
        int             fg_shift;       /* Shift  for foreground color */

        ggi_pixel       bg_mask;        /* Bitmask of background color */
        int             bg_shift;       /* Shift  for background color */

        ggi_pixel       texture_mask;   /* Bitmask of the texture (for
                                           textmodes - the actual character)
*/
        int             texture_shift;  /* Shift  for texture */

</programlisting>

<para> 
The above is used to describe a pixel simply.  More detailed information, if
required, can be obtained from the following fields.  See
<filename>ggi/ggi.h</filename> for a listing of bitmeanings.

<programlisting>
        /*
         * Now if this doesn't suffice you might want to parse the following
         * to find out what each bit does:
         */

        uint32          bitmeaning[sizeof(ggi_pixel)*8];

        /* Shall we keep those ?
         */
        uint32          flags;          /* Pixelformat flags */

        uint32          stdformat;      /* Standard format identifier */
        /* This one has only one use for the usermode application:
         * To quickly check, if two buffers are identical. If both
         * stdformats are the same and _NOT_ 0 (which means "WEIRD"),
         * you may use things like memcpy between them which will have
         * the desired effect ...
         */

} ggi_pixelformat;

/* Pixelformat flags */
#define GGI_PF_REVERSE_ENDIAN   0x01
#define GGI_PF_HIGHBIT_RIGHT    0x02
#define GGI_PF_HAM              0x04
#define GGI_PF_EXTENDED         0x08
</programlisting>
</para>

<para>
<structfield/depth/ and <structfield/size/ are same as the depth and access
size information specified in the <type/ggi_graphtype/.
</para>
<para>
<structfield/clut_mask/ is used in GT_PALETTE modes, indicating which bits
correspond to an index to the CLUT (color look-up table).
</para>
<para>
<structfield/fg_mask/, <structfield/bg_mask/, and <structfield/texture_mask/
are for text modes only, indicating the parts of the text-mode character.
</para>



<refentry id="ggiGetPixelFormat">

<refmeta>
<refentrytitle><function/ggiGetPixelFormat/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiGetPixelFormat/
<refpurpose>Get a structure describing the format of a pixelvalue from a visual</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisInfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisInfo>
<funcprototype>
<funcdef>ggi_pixelformat *<function/ggiGetPixelFormat/</funcdef>
<paramdef>ggi_visual_t <parameter/vis/</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>This function obtains the default pixel format for the given visual.
</para>
</refsect1>

<refsect1>
<title>Return value</title>
<para>Returns a pointer to the <structname/ggi_pixelformat/ structure.
</para>

<para>
Modifying the structure returned is not allowed.  Do not attempt to free
the pointer returned.  <!-- Apparently this is not clear enough. -->
</para>

</refsect1>

<refsect1>
<title>Structures</title>

<para>
See <filename>ggi/ggi.h</filename> or <xref linkend="ggi-pixelformat">
for details on the structure that is returned.
</para>

</refsect1>

</refentry>
</chapter>


