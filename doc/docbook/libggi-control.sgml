<chapter id="libggi-c-api">
<title/Using LibGGI from C programs/

<para>
Include the header <filename>ggi/ggi.h</filename> in the C program, and
link with <option/-lggi/.
</para>

<para>
LibGGI functions are prefixed with <literal/ggi/, and most other
#defines are prefixed with <literal/GGI_/.
</para>

<para>
Most LibGGI functions return <returnvalue/0/ to indicate success, and a
negative error code to indicate errors.  Return codes greater than
<returnvalue/0/ are usually additional hints or other non-negative
integer data.  A list of error codes and descriptions can be found in
the <filename>ggi/errors.h</filename> file, which is part of the
LibGGI/LibGG package.
</para>

<sect1 id="libggi-threadsafety">
<title/Thread-safety in LibGGI/

<para>
LibGGI currently only guarantees inter-<link linkend="visual"/visual/
threadsafety, meaning that you can have multiple threads opening and
using one visual each, but you can't have several threads using the same
visual.  If the application is drawing directly to a <link
linkend="directbuffer"/DirectBuffer/, however, it can have any number
of threads banging on it.  If an application needs to access one visual
from different threads, then it must do the locking itself.  The library
does not do this locking to avoid bloat for something most applications
do not require.
</para>

<!-- I hope Marcus will forgive me for pasting and munging his posts to
the ML :) -->

</sect1>


</chapter>



<chapter id="libggi-control">
<title>Library control</title>



<refentry id="ggiInit">

<refmeta>
<refentrytitle><function/ggiInit/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiInit/
<refname/ggiExit/
<refpurpose/Initialize and uninitialize LibGGI/
</refnamediv>

<refsynopsisdiv><funcsynopsis>
<funcsynopsisinfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisinfo>

<funcprototype>
<funcdef>int <function/ggiInit/</funcdef>
<void>
</funcprototype>

<funcprototype>
<funcdef>int <function/ggiExit/</funcdef>
<void>
</funcprototype>

</funcsynopsis></refsynopsisdiv>


<refsect1>
<title>Description</title>

<para>
<function/ggiInit/ initalizes the library. This function must be called
before using other LibGGI functions; otherwise the results will be
undefined.
</para>

<para>
<function/ggiExit/ uninitializes the library (after being initalized by
<function/ggiInit/) and automatically cleanup if necessary.  This should
be called after an application is finished with the library.  If any GGI
functions are called after the library has been uninitialized, the
results will be undefined.
</para>

<para>
<function/ggiInit/ allows multiple invocations.  A reference count is
maintained, and to completely uninitialize the library,
<function/ggiExit/ must be called as many times as <function/ggiInit/
has been called beforehand.
</para>

</refsect1>

<refsect1>
<title/Return value/

<para>
<function/ggiInit/ returns <returnvalue/0/ for OK, otherwise an error
code.
</para>

<para>
<function/ggiExit/ returns:

<variablelist>

<varlistentry>
<term><returnvalue/0/</term>
<listitem><para>
after successfully cleaning up,
</para></listitem>
</varlistentry>

<varlistentry>
<term><returnvalue/&gt; 0/</term>
<listitem><para>
the number of 'open' <function/ggiInit/ calls, if there has been more
than one call to <function/ggiInit/.  As <function/ggiInit/ and
<function/ggiExit/ must be used in properly nested pairs, e.g. the first
<function/ggiExit/ after two <function/ggiInit/s will return 1.
</para></listitem>
</varlistentry>

<varlistentry>
<term><returnvalue/&lt; 0/</term>
<listitem><para>
error, especially if more <function/ggiExit/ calls have been done than
<function/ggiInit/ calls.
</para></listitem>
</varlistentry>

</variablelist>

</para>
</refsect1>

<refsect1>
<title/Examples/

<example>
<title/Initialize and uninitialize LibGGI/

<programlisting format="linespecific">
if (ggiInit() < 0)
{
	fprintf(stderr, "Cannot initalize LibGGI!\n");
	exit(1);
}

<replaceable>/* Do some LibGGI stuff */</replaceable>

ggiExit();
</programlisting>

</example>
</refsect1>

</refentry>







<refentry id="ggiPanic">

<refmeta>
<refentrytitle><function/ggiPanic/</refentrytitle>
<manvolnum/3ggi/
<refmiscinfo/GGI/
</refmeta>

<refnamediv>
<refname/ggiPanic/
<refpurpose>Exit LibGGI programs for fatal errors</refpurpose>
</refnamediv>

<refsynopsisdiv><funcsynopsis>
<funcsynopsisinfo>#include &lt;ggi/ggi.h&gt;</funcsynopsisinfo>

<funcprototype>
<funcdef>int <function>ggiPanic</function></funcdef>
<paramdef>
const char *<parameter/format/, 
<replaceable/.../
</paramdef>
</funcprototype>

</funcsynopsis></refsynopsisdiv>

<refsect1>
<title/Description/

<para>
<function/ggiPanic/ shuts down the application, closing all
visuals, with 

<citerefentry>
<refentrytitle><function/printf/</refentrytitle>
<manvolnum/3/
</citerefentry>

-style reporting to stderr, taking a format string and any additional variables. 
</para>

<para>
<function/ggiPanic/ should only be used by usermode programs when
something is really screwed, and they do not know what to do. The same
applies for libraries, but might be used in rare situations such as
corruption of critical data structures.
</para>

</refsect1>

<refsect1>
<title/Return value/
<para>
Never returns.
</para>
</refsect1>

<refsect1>
<title/Examples/

<example>
<title/An unrecoverable error/

<programlisting format="linespecific">
if (my_important_struct->magic != MAGIC) {
        ggiPanic("Fatal error: structure is corrupted\n");
}
</programlisting>
</example>
</refsect1>

</refentry>

</chapter>




