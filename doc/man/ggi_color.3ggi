.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "GGI_COLOR" 3ggi "" "" ""
.SH NAME
ggi_color, ggi_pixel \- LibGGI color description
.SH "SYNOPSIS"

.nf
#include <ggi/ggi.h>

.fi

.SH "DESCRIPTION"

.nf

typedef struct { uint16 r,g,b,a; }   ggi_color;

.fi

.nf

typedef uint32   ggi_pixel;

.fi

.PP
Colors in ggi are described genericaly through the display-independent ggi_color structure. 16 bit channels are used to ensure sufficient precision most displays.

.PP
\fBggi_pixel\fRs are display-dependent pixel values. They are used by all GGI drawing primitives for efficiency. Use \fBggiMapColor\fR to convert ggi_colors to ggi_pixels.

.SH "STRUCTURE MEMBERS"

.PP
 r, g and b correspond respectively to the red, green and blue channels. Since libggi does not deal with alpha compositing, the a(alpha) field is mainly there for padding and it is not used by libggi. Setting this value has no effect in libggi itself, and it will most probably not be unmaped correctly from \fBggi_pixel\fRs. However, some extensions might make use of it, in which case you should refer to their documentation.

.PP
 \fBggi_pixel\fRs format depends on the actual display and mode. For those who want to operate directly on pixel values, this format is describe in the ggi_pixelformat structure.

.SH "PIXEL ARRAYS"

.PP
Although individual pixels are kept into 32 bits \fBggi_pixel\fR, arrays of pixels, as used in \fBggi[Get¦Put]*\fR functions, \fBggiPackColors\fR and \fBggiUnpackPixels\fR, are stored in the display specific format, thus packed according to the actual pixel size. This size is given by the GT_SIZE macro for \fBgraphtype\fR or the size field of the ggi_pixelformat structure.

.PP
The buffers provided to these functions must be big enough to store or read enough pixels. Although it is safe to use 32 bits per pixel, the optimum size (in bits) can be calculated by multiplying the number of pixel by their size. Don't forget to round up to a multiple of 8 to get the number of bytes.

.PP
If you want to access such buffers directly, do not use pointer arithmetics with \fBggi_pixel\fRs.

.SH "SEE ALSO"
, , 
