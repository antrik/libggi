.TH "ggi_mode" 3 GGI
.SH NAME
ggi_mode, ggi_coord, ggi_graphtype \- LibGGI mode description
.SH SYNOPSIS
#include <ggi/ggi.h>
.SH DESCRIPTION
.nf

typedef struct { sint16 x, y; } ggi_coord;

.fi
.nf

typedef uint32 ggi_graphtype;

.fi
.nf

typedef struct
{
        sint32          frames;
        ggi_coord       visible;
        ggi_coord       virt;
        ggi_coord       size;
        ggi_graphtype   graphtype;
        ggi_coord       dpp;
} ggi_mode;

.fi
The mode structure describes a visual configuration given by its size and other graphic properties.
.SH STRUCTURE MEMBERS
.TP
\fBframes\fR
The number of frames. Some displays have multi-buffer capabilites (double-buffering, triple-buffering...). See libggi for information on working with multiple frames.
.PP
.TP
\fBvisible\fR
The size of the visible area. This is what the user will see.
.PP
.TP
\fBvirt\fR
The virtual size of the visual. It can be larger (but not smaller) than the visible area, in which case only a part of it is displayed. It is useful for scrolling or backing up portions of screen efficiently. See for more.
.PP
.TP
\fBsize\fR
???
.PP
.TP
\fBgraphtype\fR
It holds information on the type of display. libggi defines macros to construct graphtypes values or access individual field.
.TP
\fBdepth\fR ( \fBGT_DEPTH\fR(gt), \fBGT_SETDEPTH\fR(gt,x) )
The number of significant bits holding color information.
.PP
.TP
\fBsize\fR ( \fBGT_SIZE\fR(gt), \fBGT_SETSIZE\fR(gt,x) )
The actual size (in bits) of a pixel. For instance, on a 32 bits X server the pixel size is 32 but the depth is only 24 (8bits RGB channels, 8 unused).
.PP
.TP
\fBscheme\fR ( \fBGT_SCHEME\fR(gt), \fBGT_SETSCHEME\fR(gt,x) )
The following schemes are available :
.RS
.IP \(bu 4
\fBGT_TEXT\fR : text mode only
.IP \(bu 4
\fBGT_TRUECOLOR\fR :
.IP \(bu 4
\fBGT_GREYSCALE\fR : pixels represent level of gray
.IP \(bu 4
\fBGT_PALETTE\fR : pixels are entries in a CLUT (Color Look-Up Table)
.IP \(bu 4
\fBGT_STATIC_PALETTE\fR
.IP \(bu 4
\fBGT_SUBSAMPLE_YUV\fR
.IP \(bu 4
\fBGT_SUBSAMPLE_U_YCRBR\fR
.IP \(bu 4
\fBGT_SUBSAMPLE_S_YCRBR\fR
.IP \(bu 4
\fBGT_NIL\fR
.RE
.PP
.TP
\fBsubscheme\fR ( \fBGT_SUBSCHEME\fR(gt), \fBGT_SETSUBSCHEME\fR(gt,x) )
????
.RS
.IP \(bu 4
\fBGT_SUB_REVERSE_ENDIAN\fR
.IP \(bu 4
\fBGT_SUB_HIGHBIT_RIGHT\fR
.IP \(bu 4
\fBGT_SUB_PACKED_GETPUT\fR
.RE
.PP
Graphtypes can be constructed directly or via the \fBGT_CONSTRUCT\fR(depth,scheme,size) macro. The following common graphtypes are defined :
.RS
.IP \(bu 4
\fBGT_TEXT16\fR
.IP \(bu 4
\fBGT_TEXT32\fR
.IP \(bu 4
\fBGT_1BIT\fR
.IP \(bu 4
\fBGT_2BIT\fR
.IP \(bu 4
\fBGT_4BIT\fR
.IP \(bu 4
\fBGT_8BIT\fR
.IP \(bu 4
\fBGT_15BIT\fR
.IP \(bu 4
\fBGT_16BIT\fR
.IP \(bu 4
\fBGT_24BIT\fR
.IP \(bu 4
\fBGT_32BIT\fR
.IP \(bu 4
\fBGT_AUTO\fR
.IP \(bu 4
\fBGT_INVALID\fR
.RE
.PP
.TP
\fBdpp\fR
It stands for dot-per-pixel.
.PP
When filling a mode structure for setting a visual, any field can be assigned \fBGGI_AUTO\fR (\fBGT_AUTO\fR for graphtype) if a specific value isn't required.
.SH SEE ALSO
\fBggiCheckMode\fR (3), \fBggiSetMode\fR (3) 
