.\\" auto-generated by docbook2man-spec $Revision: 1.4 $
.TH "ggiDBGetBuffer" "3ggi" "14 August 2001" "GGI" "LibGGI API"
.SH NAME
ggiDBGetNumBuffers, ggiDBGetBuffer \- Get DirectBuffers from a visual
.SH SYNOPSIS
\fB#include <ggi/ggi.h>
.sp
int ggiDBGetNumBuffers(ggi_visual_t \fIvis\fB);
.sp
const ggi_directbuffer *ggiDBGetBuffer(ggi_visual_t \fIvis\fB, int \fIbufnum\fB);
\fR.SH "DESCRIPTION"
.PP
\fBggiDBGetNumBuffers\fR returns the number of DirectBuffers available
to the application.
\fBggiDBGetBuffer\fR obtains the DirectBuffer at the specified
position.
.PP
Use \fBggiDBGetBuffer\fR to obtain the DirectBuffers at 0 to
n-1, where n is the number returned by \fBggiDBGetNumBuffers\fR.
.PP
Pixel-linear buffers have type==GGI_DB_SIMPLE_PLB | GGI_DB_NORMAL.
You're on your own now.
.PP
DirectBuffers where \fBggiResourceMustAcquire\fR is true need to be
\&'acquired' (i.e. locked) before using. An acquire is done by using
\fBggiResourceAcquire\fR and is released by calling
\fBggiResourceRelease\fR. 
(See \fBggiResourceAcquire\fR(3).)
Beware that the \fBread\fR, \fBwrite\fR and
\fBstride\fR fields of the DirectBuffer may be changed by an
acquire, and that they may be \fBNULL\fR or invalid when the
DirectBuffer is not acquired.
.SH "RETURN VALUE"
.PP
\fBggiDBGetNumBuffers\fR returns the number of DirectBuffers
available. 0 indicates that no DirectBuffers are available.
.PP
\fBggiDBGetBuffer\fR returns a pointer to a DirectBuffer
structure.
.SH "EXAMPLES"
.SS "HOW TO OBTAIN A DIRECTBUFFER"
.sp
.nf

ggi_visual_t	vis;
ggi_mode	mode;
int		i;

/* Framebuffer info */
unsigned char *fbptr[2];
int stride[2];
int numbufs;

mode.frames = 2;	/* Double-buffering */
mode.visible.x = 640;	/* Screen res */
mode.visible.y = 480;
mode.virt.x = GGI_AUTO;	/* Any virtual resolution.  Will usually be set
mode.virt.y = GGI_AUTO;	   to be the same as visible but some targets may
			   have restrictions on virtual size. */
mode.graphtype = GT_8BIT;		/* Depend on 8-bit palette. */
mode.dpp.x = mode.dpp.y = GGI_AUTO;	/* Always 1x1 but we don't care. */

if(ggiInit())
{
	/* Failed to initialize library. Bomb out. */
}

vis = ggiOpen(NULL);
if(!vis)
{
	/* Opening default visual failed, quit. */
}

if(ggiSetMode(vis, &mode))
{
	/* Set mode has failed, should check if suggested mode
	   is o.k. for us, and try the call again. */
}

numbufs = ggiDBGetNumBuffers(vis);

for(i = 0; i < numbufs; i++)
{
	ggi_directbuffer *db;
	int frameno;

	db = ggiDBGetBuffer(vis, i);

	if(!(db->type & GGI_DB_SIMPLE_PLB))
	{
\fI		/* We don't handle anything but simple pixel-linear buffers.
		   Fall back to ggiPutBox() or something. */
		continue;\fR
	}

	frameno = db->frame;

	if(readptr[frameno] != NULL &&
		(db->buffer.plb.pixelformat->flags & GGI_PF_REVERSE_ENDIAN))
	{
		\fIcontinue;\fR
	}

	fbptr[frameno] = db->write;	/* read == write for simple plbs */

	/* Stride of framebuffer (in bytes). */
	stride[frameno] = db->buffer.plb.stride;

	\fI/* Check pixel format, be portable.... */\fR
.sp
.fi
