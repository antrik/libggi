.\"Generated by ggi version of db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "GGIDBGETBUFFER" 3 "" "" ""
.SH NAME
ggiDBGetNumBuffers, ggiDBGetBuffer \- Get DirectBuffers from a visual
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ggi/ggi.h>
.sp
.HP 24
int\ \fBggiDBGetNumBuffers\fR\ (ggi_visual_t\ \fIvis\fR);
.HP 41
const\ ggi_directbuffer\ *\fBggiDBGetBuffer\fR\ (ggi_visual_t\ \fIvis\fR, int\ \fIbufnum\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
Dependent on the visual and runtime environment found, applications may be granted direct access to hardware and/or library internal buffers. This may significantly enhance performance for certain pixel oriented applications or libraries.

.PP
The DirectBuffer is a mechanism in which a LibGGI program can use to determine all the characteristics of these buffers (typically the framebuffer), including the method of addressing, the stride, alignment requirements, and endianness.

.PP
However, use not conforming to this specification will have undefined effects and may cause data loss or corruption, program malfunction or abnormal program termination. So you don't really want to do this.

.PP
 \fBggiDBGetNumBuffers\fR returns the number of DirectBuffers available to the application. \fBggiDBGetBuffer\fR obtains the DirectBuffer at the specified position.

.PP
Use \fBggiDBGetBuffer\fR to obtain the DirectBuffers at 0 to n-1, where n is the number returned by \fBggiDBGetNumBuffers\fR.

.PP
Pixel-linear buffers have type==GGI_DB_SIMPLE_PLB | GGI_DB_NORMAL. You're on your own now.

.PP
DirectBuffers where \fBggiResourceMustAcquire\fR is true need to be 'acquired' (i.e. locked) before using. An acquire is done by using \fBggiResourceAcquire\fR and is released by calling \fBggiResourceRelease\fR. (See \fBggiResourceAcquire\fR(3).) Beware that the read, write and stride fields of the DirectBuffer may be changed by an acquire, and that they may be NULL or invalid when the DirectBuffer is not acquired.

.SH "RETURN VALUE"

.PP
\fBggiDBGetNumBuffers\fR returns the number of DirectBuffers available. 0 indicates that no DirectBuffers are available.

.PP
\fBggiDBGetBuffer\fR returns a pointer to a DirectBuffer structure.

.SH "TYPES OF BUFFERS"

.PP
Only the framebuffer is defined currently. Other types of buffers, such as stencil, z will be defined by appropriate GGI extensions.

.PP
A frame buffer may be organized as several distinct buffers. Each buffer may have a different layout. This means both the addressing scheme to be used as well as the addressing parameters may differ from buffer to buffer.

.PP
A framebuffer is denoted by ggi_directbuffer.type==GGI_DB_NORMAL. Each frame has its own buffer, and its number is indicated in ggi_directbuffer.frame.

.SH "EXAMPLES"
Example 16. How to obtain a DirectBuffer
.nf

ggi_visual_t	vis;
ggi_mode	mode;
int		i;

/* Framebuffer info */
unsigned char *fbptr[2];
int stride[2];
int numbufs;

mode.frames = 2;	/* Double-buffering */
mode.visible.x = 640;	/* Screen res */
mode.visible.y = 480;
mode.virt.x = GGI_AUTO;	/* Any virtual resolution.  Will usually be set
mode.virt.y = GGI_AUTO;	   to be the same as visible but some targets may
			   have restrictions on virtual size. */
mode.graphtype = GT_8BIT;		/* Depend on 8-bit palette. */
mode.dpp.x = mode.dpp.y = GGI_AUTO;	/* Always 1x1 but we don't care. */

if(ggiInit())
{
	/* Failed to initialize library. Bomb out. */
}

vis = ggiOpen(NULL);
if(!vis)
{
	/* Opening default visual failed, quit. */
}

if(ggiSetMode(vis, &mode))
{
	/* Set mode has failed, should check if suggested mode
	   is o.k. for us, and try the call again. */
}

numbufs = ggiDBGetNumBuffers(vis);

for(i = 0; i < numbufs; i++)
{
	ggi_directbuffer *db;
	int frameno;

	db = ggiDBGetBuffer(vis, i);

	if(!(db->type & GGI_DB_SIMPLE_PLB))
	{
\fI
		/* We don't handle anything but simple pixel-linear buffers.
		   Fall back to ggiPutBox() or something. */
		continue;
\fR
	}

	frameno = db->frame;

	if(readptr[frameno] != NULL &&
		(db->buffer.plb.pixelformat->flags & GGI_PF_REVERSE_ENDIAN))
	{
		\fIcontinue;\fR
	}

	fbptr[frameno] = db->write;	/* read == write for simple plbs */

	/* Stride of framebuffer (in bytes). */
	stride[frameno] = db->buffer.plb.stride;

	\fI/* Check pixel format, be portable.... */\fR

.fi

.SH "SEE ALSO"
\fBggi_directbuffer\fR(3), \fBggiResourceAcquire\fR(3)
