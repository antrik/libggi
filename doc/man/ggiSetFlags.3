.\"Generated by ggi version of db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "GGISETFLAGS" 3 "" "" ""
.SH NAME
ggiSetFlags, ggiGetFlags, ggiAddFlags, ggiRemoveFlags \- Set or get flags affecting operation on a visual
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ggi/ggi.h>
.sp
.HP 17
int\ \fBggiSetFlags\fR\ (ggi_visual_t\ \fIvis\fR, ggi_flags\ \fIflags\fR);
.HP 23
ggi_flags\ \fBggiGetFlags\fR\ (ggi_visual_t\ \fIvis\fR);
.HP 17
int\ \fBggiAddFlags\fR\ (ggi_visual_t\ \fIvis\fR, ggi_flags\ \fIflags\fR);
.HP 20
int\ \fBggiRemoveFlags\fR\ (ggi_visual_t\ \fIvis\fR, ggi_flags\ \fIflags\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBggiSetFlags\fR sets the specified flags (bitwise OR'd together) on a visual. This function is usually used to set async mode on a visual (see below).

.PP
\fBggiGetFlags\fR obtains the flags currently in effect.

.PP
\fBggiAddFlags\fR and \fBggiRemoveFlags\fR are macros that set or unsets the specified flags.

.SH "RETURN VALUE"

.PP
 \fBggiSetFlags\fR, \fBggiAddFlags\fR, and \fBggiRemoveFlags\fR return 0 on success, <0 on failure.

.PP
 \fBggiGetFlags\fR returns the current flags.

.SH "SYNCHRONOUS AND ASYNCHRONOUS DRAWING MODES"

.PP
Some visuals allow different modes with regard to when the screen is updated and the actual drawing takes place.

.TP 3
\(bu
In synchronous mode when the drawing command returns, it is already or will be executed very shortly. So the visible effect is that everything is drawn immediately. (It is not guaranteed in the strict sense in that it is already drawn when the function call returns, but almost.) This is the default mode for all visuals.
.TP
\(bu
The asynchronous mode does not guarantee that drawing commands are executed immediately, but is faster on many targets. If the visual does not support asynchronous mode, setting it has no effect.

To make sure that all pending graphics operations are actually done and the screen is updated, you need to call \fBggiFlush\fR. This call is not needed in synchronous mode.)
.LP

.RS
.Sh "Warning"

.PP
On some targets such as the X target there is no real synchronous mode, so LibGGI fakes one by periodically calling \fBggiFlush\fR in the background. This process can take about half the execution time of a program. So using synchronous mode can really slow things down.

.PP
The synchronous mode is default because it is what most programmers expect.

.RE

.PP
All operations are guaranteed to be performed in the order given in both modes. Reordering is not done.

.PP
So the recommendation for all graphics applications is to set the asynchronous mode. It will be far more efficient on some platforms and will never be worse.
Example 14. Setting up asynchronous mode
.nf

ggiAddFlags(vis, GGIFLAG_ASYNC);	/* switches to asynchronous mode */

ggiFlush(vis);				/* updates the screen */

ggiRemoveFlags(vis, GGIFLAG_ASYNC);	/* switches to synchronous mode */

.fi

.SH "SEE ALSO"
\fBggiFlush\fR(3)
