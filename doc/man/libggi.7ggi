.\\" auto-generated by docbook2man-spec $Revision: 1.2 $
.TH "LIBGGI" "7ggi" "14 August 2001" "GGI" "LibGGI Reference"
.SH NAME
libggi \- A fast, simple, small and flexible user-space graphics library
.SH "DESCRIPTION"
.PP
LibGGI is a fast, simple, small and flexible user-space
graphics library developed by the GGI Project
(http://www.ggi-project.org/>. It attempts to abstract the many
different graphics output systems existing under Unix (and in the
future, other platforms). The support for all of these different
types of displays and hardware are provided by dynamically-loaded
mini-libraries.
.PP
LibGGI can transparently (to the LibGGI-using application)
display graphics on an X window, under SVGAlib, fbcon
(Linux framebuffer driver), or the glide library, through
their respective graphics drivers, or targets. There
are also some other targets which display through another target,
such as multi to display simultaneously on multiple displays at
once, and tile to tile your display to different monitors.
.PP
LibGGI supports acceleration of graphics primitives where possible.
.PP
LibGGI is a very generic piece of software, that will run on about
every platform that has remotely heard of POSIX
(ports to other systems such as Win32 are underway) and on many
display subsystems.
.SH "ENVIRONMENT VARIABLES"
.PP
The following outlines the environment variables, intended for the user,
which affect the behaviour of LibGGI:
.TP
\fBDISPLAY\fR
If set, LibGGI assumes that you want to use the \fBX\fR
target. This setting is overriden by the \fBGGI_DISPLAY\fR variable.
.TP
\fBGGI_DISPLAY\fR
Specifies the default target used when the application calls 
\fBggiOpen\fR
with \fBNULL\fR argument.

The default target is specified using a target-spec:
.sp
\fB\fItargetname\fB\fR [ \fB:\fItargetargs\fB\fR ] 
where \fItargetname\fR is the name of the target,
and \fItargetargs\fR are any target-specific arguments.

If neither this variable nor \fBDISPLAY\fR is set, then the following
targets are tried in order until one works:
\fBfbdev\fR, \fBsvga\fR, \fBaa\fR
.SS "EXAMPLE GGI_DISPLAY SETTINGS"
.sp
.nf
$ \fBGGI_DISPLAY=aa ./flying_ggis\fR\fI  # see ASCII art flying GGIs\fR
$ \fBGGI_DISPLAY=multi:(Xlib:crono:0.0):(X::0.0) ./demo\fR\fI  # see demo on both machine next door and local X at the same time\fR
.sp
.fi
.TP
\fBGGI_INPUT_\fItarget\fB_\fIn\fB\fR
.TP
\fBGGI_INPUT_\fItarget\fB\fR
.TP
\fBGGI_INPUT\fR
\fBGGI_INPUT_\fItarget\fB\fR specifies extra LibGII input sources and/or filters for visuals 
using \fItarget\fR.

Multiple inputs can be specified by enclosing each input-spec in parentheses 
and separating them with semicolons:
.sp
 \fB(\fIi1\fB):\fR\fI...\fR

The inputs specified by 
\fBGGI_INPUT_\fItarget\fB_\fIn\fB\fR are only
opened at the \fIn\fRth call of \fBggiOpen\fR.
This is used for misbehaving applications that do not allow the user to
specify inputs for the different targets that it opens.

The \fBGGI_INPUT\fR variable specifies input settings for all
other targets not specified using the other two variable forms.
.SS "EXAMPLE GGI_INPUT STRINGS"
.sp
.nf
$ \fBexport GGI_INPUT=linux-mouse:auto\fR\fI  # all targets\fR
$ \fBexport GGI_INPUT_multi=linux-mouse:auto\fR\fI  # for multi target only\fR
.sp
.fi
.TP
\fBGGI_DEFMODE\fR
Specifies the default mode, which is used for mode negotiation with
LibGGI applications. Specifically, when \fBGGI_AUTO\fR or \fBGT_AUTO\fR are specified in a 
mode setting call they will be replaced with values from 
\fBGGI_DEFMODE\fR before calling the target's own
\fBggiSetMode\fR implementation.

The format is: (all on one line)
.sp
.nf
S \fI<x>\fR x \fI<y>\fR x \fI<depth>\fR
V \fI<x>\fR x \fI<y>\fR
D \fI<x>\fR x \fI<y>\fR
F \fI<frames>\fR
[ \fI<scheme>\fR \fI<depth>\fR / \fI<size>\fR ]
.sp
.fi
Anything and everything can be omitted, except tokens indicating what
the next token is.

Any omitted values default to \fBGGI_AUTO\fR (or \fBGT_AUTO\fR for
the graphtype). Whitespace and '.' symbols are ignored. Character
tokens are case-insensitive. If certain values are not possible, they
are overridden by the target.
.RS
.TP
\fBS\fR
Denotes the visible size of
the visual. Totally optional, as dimensions without a specifier are
considered to be the visible dimensions.
.TP
\fB\fI<x>\fB\fR
.TP
\fB\fI<y>\fB\fR
The width (\fIx\fR) and height (\fIy\fR), in pixels.
.TP
\fBV\fR
Denotes virtual size, the
total drawing area available to the application. The virtual size
must be equal or greater than the visible size.
.TP
\fBD\fR
Denotes the number of dots per
pixel. For graphics modes, this is always 1x1, and for text
modes, this is the size of the character cell.
.TP
\fBF\fR
Denotes number of frames
available to the application. Applications can switch between
different frames for double-buffering, etc.
.TP
\fB[\fR
.TP
\fB]\fR
Delimits the graphic type.
.TP
\fB\fI<scheme>\fB\fR
One of:
.RS
.TP
\fBC\fR
\fBGT_TRUECOLOR\fR
.TP
\fBP\fR
\fBGT_PALETTE\fR
.TP
\fBK\fR
\fBGT_GREYSCALE\fR
.TP
\fBT\fR
\fBGT_TEXT\fR
.RE
.PP
.TP
\fB\fI<depth>\fB\fR
Pixel depth in number of bits.
.TP
\fB\fI<size>\fB\fR
Size of pixel in number of bits, including padding.
.RE
.PP
Instead of \fIscheme\fR, \fIdepth\fR, \fIsize\fR, it
is also possible to specify the graphtype by using one of the following:
\fBGT_1BIT\fR, \fBGT_2BIT\fR, \fBGT_4BIT\fR, \fBGT_8BIT\fR, \fBGT_15BIT\fR, \fBGT_16BIT\fR, \fBGT_24BIT\fR, \fBGT_32BIT\fR, \fBGT_TEXT16\fR, \fBGT_TEXT32\fR
.PP
.SS "EXAMPLES OF GGI_DEFMODE STRINGS"
.RS
.TP
\fB640x480\fR
just the visible size
.TP
\fB640x480#640x960\fR
same size, but double-height virtual screen
.TP
\fB#1024x768\fR
only virtual size defined
.TP
\fB80x40[T]\fR
(default-fontsized) text mode with 80x40 characters
.TP
\fB#x100[T]\fR
text mode with 100 virtual lines
.TP
\fB640x400[8]\fR
640x400 at 8 bits per pixel
.TP
\fB640x480[GT_8BIT]\fR
same as above, but palettized
.TP
\fB320x200x15\fR
.TP
\fB320x200[C15]\fR
320x200 with 32768 colors (hicolor)
.TP
\fB320x200[C16]/\fR
320x200 with 16-bit pixels (also hicolor)
.TP
\fB320x200[C2432]/\fR
.TP
\fB320x200[GT_32BIT]\fR
320x200, with 32-bit pixels for 16777216 colors (truecolor)
.TP
\fB640x480F2[GT_16BIT]\fR
16-bit-color 640x480 with two buffers
.RE
.PP
.TP
\fBGGI_DEBUG\fR
The debugging level for LibGGI:
.RS
.TP
\fB0 or unset\fR
debug output is off; debugging is off
.TP
\fB255\fR
all debug output is on
.RE

You may also bitwise-or any of the following together:
.RS
.TP
\fB2\fR
debug core
.TP
\fB4\fR
debug mode setting
.TP
\fB8\fR
debug color handling
.TP
\fB16\fR
debug drawing
.TP
\fB32\fR
misc debugging output
.TP
\fB64\fR
debug dynamic library handling
.TP
\fB128\fR
debug event handling
.RE

The debugging output can be quite verbose and in most cases you should
redirect stderr so that it does not interfere with your program's
output.
.TP
\fBGGI_DEBUGSYNC\fR
Turn on synchronous debugging output, flushing the output buffers before
returning from \fBGGIDPRINT\fR calls.
.TP
\fBFRAMEBUFFER\fR
Specifies which framebuffer device file the \fBfbdev\fR target
should use.
.TP
\fBGGI_NEWVT\fR
If set, causes a new virtual console to be allocated for some
Linux-console-based targets (currently \fBfbdev\fR and
\fBglide\fR).
.TP
\fBGGI_MANSYNC_FPS\fR
This variable specifies the framerate for targets emulating synchronous mode. The default is 20fps. If
you are experiencing problems with the X target over relatively slow
remote connections it might be due to connection overload. You might
want to try with a lower \fBGGI_MANSYNC_FPS\fR setting.
