.\" This manpage has been automatically generated by docbook2man 
.\" from a DocBook document.  This tool can be found at:
.\" <http://shell.ipoline.com/~elmert/comp/docbook2X/> 
.\" Please send any bug reports, improvements, comments, patches, 
.\" etc. to Steve Cheng <steve@ggi-project.org>.
.TH "LIBGGI" "7ggi" "04 July 1999" "GGI" ""
.SH NAME
libggi \- a fast, simple, small and flexible user-space graphics library
.SH "DESCRIPTION"
.PP
\fBLibGGI\fR is a fast, simple, small and flexible user-space
graphics library developed by the GGI Project <URL:http://www.ggi-project.org/>. It attempts to abstract the many different graphics
output systems existing under Unix (and in the future, other platforms).
The support for all of these different types of displays and hardware
are provided by dynamically-loaded mini-libraries.
.PP
\fBLibGGI\fR can transparently (to the LibGGI-using application)
display graphics on an X window, under SVGAlib, fbcon (Linux framebuffer
driver), or the glide library, through their respective graphics
drivers, or \fItargets\fR.  There are also some other targets
which display through another target, such as 
\fBmulti\fR to display simultaneously on multiple
displays at once, and \fBtile\fR to tile your
display to different monitors.
.PP
\fBLibGGI\fR supports acceleration of graphics primitives where possible.
.PP
\fBLibGGI\fR is a very generic piece of software, that will run
on about every platform that has remotely heard of 
\fBPOSIX\fR (ports to other systems such as 
\fBWin32\fR are underway) and on many display subsystems.
.SH "ENVIRONMENT VARIABLES"
.PP
The following outlines the environment variables, intended for the user,
which affect the behaviour of LibGGI:
.TP
\fBDISPLAY\fR
If set, assumes that you want to use the \fBX\fR
target. Can be overriden by the \fBGGI_DISPLAY\fR variable.
.TP
\fBGGI_DISPLAY\fR
Specifies the default target (used when the application calls \fBggiOpen\fR(\fBNULL\fR))
.sp
\fI<target>\fR[:\fI<targetargs>\fR]
.PP
.PP
Multiple inputs can be specified by this notation:
.sp
(\fI<i1>\fR):(\fI<i2>\fR) ...
.PP
.PP
.PP
If neither this variable nor \fBDISPLAY\fR is set, then the following
targets are tried in order until one works:
\fBfbdev\fR, \fBsvga\fR, \fBaa\fR
.PP
.TP
\fBGGI_INPUT\fR
Specifies extra LibGII input sources for all \fIvisuals\fR
(an opened display).
See \fBlibgii\fR(7)
for details on the format.

You can also append the name of a specific target to the environment
variable name to specify extra input sources for that target.  For
example:

.sp
.sp
.nf
  $ \fBexport GGI_INPUT=linux-mouse:auto\fR\fI	# all targets\fR
  $ \fBexport GGI_INPUT_multi=linux-mouse:auto\fR\fI	# for multi-target only\fR
  
.sp
.fi
.TP
\fBGGI_DEFMODE\fR
Specifies the default mode, which is used for mode negotiation with
LibGGI applications.  Specifically, when \fBGGI_AUTO\fR or
\fBGT_AUTO\fR are specified in a mode setting call they will be
replaced with values from \fBGGI_DEFMODE\fR before calling the
target's own set-mode implementation.

The format is: (all on one line, of course)
.sp
S \fI<x>\fR x \fI<y>\fR x \fI<depth>\fR
V \fI<x>\fR x \fI<y>\fR
D \fI<x>\fR x \fI<y>\fR
F \fI<frames>\fR
[ \fI<scheme>\fR \fI<depth>\fR / \fI<size>\fR ]
.PP
Anything and everything can be omitted, 
except tokens indicating what the next number is.
Any omitted values default to \fBGGI_AUTO\fR (or \fBGT_AUTO\fR for the graphtype).  
Whitespace and '.' symbols are ignored.
Character tokens are case-insensitive.
If certain values are not possible, they are overridden by the target.
.RS
.TP
\fB\&'S'\fR
Denotes visible size, which is the area visible to the user.
Totally optional, as dimensions without a specifier are considered 
to be the visible dimensions.
.TP
\fB\fI<x>\fB\fR
.TP
\fB\fI<y>\fB\fR
(\fIx\fR,\fIy\fR) dimensions, in pixels.
.TP
\fB\&'V'\fR
Denotes virtual size, the total drawing area available to the application.
The virtual size must be equal or greater than the visible size.
.TP
\fB\&'D'\fR
Denotes the number of dots-per-pixel.  For graphics modes, this is always
1x1, and for text modes, this is the size of the character cell.
.TP
\fB\&'F'\fR
Denotes number of frames available to the application.
Applications can switch between different frames for double-buffering,
etc.
.TP
\fB\&'['\fR
.TP
\fB\&']'\fR
Delimits the graphics type.
.TP
\fB\fI<scheme>\fB\fR
One of:
.RS
.TP
\fBC\fR
Colored
.TP
\fBP\fR
Palettized (indexed-color) mode
.TP
\fBK\fR
Greyscale
.TP
\fBT\fR
Text (character-cell) mode
.PP
.RE
.TP
\fB\fI<depth>\fB\fR
Pixel depth in number of bits.
.TP
\fB\fI<size>\fB\fR
Size of pixel in number of bits, including padding.
.PP
.RE

Instead of \fIscheme\fR, \fIdepth\fR, \fIsize\fR, it
is also possible to specify the graphtype by using one of the following:
\fBGT_1BIT\fR, \fBGT_2BIT\fR, \fBGT_4BIT\fR, \fBGT_8BIT\fR, \fBGT_15BIT\fR, \fBGT_16BIT\fR, \fBGT_24BIT\fR, \fBGT_32BIT\fR, \fBGT_TEXT16\fR, \fBGT_TEXT32\fR
.SS "EXAMPLES OF GGI_DEFMODE STRINGS"
.RS
.TP
\fB640x480\fR
just the visible size
.TP
\fB640x480#640x960\fR
same size, but double-height virtual screen
.TP
\fB#1024x768\fR
only virtual size defined
.TP
\fB80x40[T]\fR
(default-fontsized) text mode with 80x40 characters
.TP
\fB#x100[T]\fR
text mode with 100 virtual lines
.TP
\fB640x400[8]\fR
640x400 at 8 bits per pixel
.TP
\fB640x480[GT_8BIT]\fR
same as above, but palettized
.TP
\fB320x200x15\fR
.TP
\fB320x200[C15]\fR
320x200 with 32768 colors (hicolor)
.TP
\fB320x200[C/16]\fR
320x200 with 16-bit pixels (also hicolor)
.TP
\fB320x200[C24/32]\fR
.TP
\fB320x200[GT_32BIT]\fR
320x200, with 32-bit pixels, 16777216 colors (truecolor)
.PP
.RE
.TP
\fBGGI_DEBUG\fR
The debugging level for \fBLibGGI\fR:
.RS
.TP
\fB0 or unset\fR
debug output is off; debugging is off
.TP
\fB255\fR
all debug output is on
.PP
.RE

You may also bitwise 'or' any of the following together:
.RS
.TP
\fB2\fR
debug core
.TP
\fB4\fR
debug mode setting
.TP
\fB8\fR
debug color handling
.TP
\fB16\fR
debug drawing
.TP
\fB32\fR
misc debugging output
.TP
\fB64\fR
debug dynamic library handling
.TP
\fB128\fR
debug event handling
.PP
.RE
.TP
\fBGGI_DEBUGSYNC\fR
Turn on synchronous debugging output, flushing the output buffers
before returning from \fBDPRINT\fR calls.
.TP
\fBFRAMEBUFFER\fR
Specifies which framebuffer device file the 
\fBfbdev\fR target should use.
.TP
\fBGGI_NEWVT\fR
If set, causes a new virtual console to be allocated for some 
Linux-console-based targets (currently \fBfbdev\fR
and \fBglide\fR).
.TP
\fBGGI_MANSYNC_FPS\fR
This variable specifies the framerate for targets emulating SYNC
mode (manual sync).  The default is 20fps.  If you are experiencing
problems with the X target over realtively slow remote connections it
might be due to connection overload. You might want to try with a lower
\fBGGI_MANSYNC_FPS\fR setting.
.SH "DISPLAY TARGETS"
.SS "PRIMARY TARGETS"
.TP
\fBX \fR
Displays in an X window.

Emulates a linear framebuffer which is blitted to the X server
with the \fBXPutImage\fR function. In ASYNC mode this is done
when \fBggiFlush\fR is called, and in SYNC mode it is done
periodicly in the background (with the framerate specified by
\fBGGI_MANSYNC_FPS\fR).  The MITSHM extension is used when available
for maximum speed.

.sp
\fBdisplay-x\fR \fB:\fR [ \fB [ -inroot ]  [ -inwin=\fIwinid\fB ] \fR ]  [ \fB\fIdisplay\fB\fR ] 
.RS
.TP
\fB\fIdisplay\fB\fR
The X display to connect to, otherwise defaults to
the display specified in \fBDISPLAY\fR 
.TP
\fB-inroot\fR
Run in root window
.TP
\fB-inwin=\fIwinid\fB\fR
Run in already-existing window with id \fIwinid\fR
.PP
.RE

In this target,
\fBCtrl\fR+\fBAlt\fR+\fBm\fR toggles mouse
grabbing.  It will try to emulate a "relative" mouse device, i.e. one
that can be moved arbitrarily far in any direction without ever
leaving the window.  This is useful for game controls, where loosing
focus is generally undesireable.  Note that grabbing must be turned
off in order to leave the window.

Other features:

\fIDirectBuffer\fR (direct framebuffer access) always available.

Unaccelerated

Multiple frames

Panning
.TP
\fBXlib \fR
Uses Xlib primitives to do drawing. Faster than \fBX\fR target when using drawing primitives on on
accelerated X server. Blitting is slower when running local to the X
server.  

This target has the same options and hotkeys as 
\fBX\fR target.

Other features:

DirectBuffer never available.

Accelerated if the hosting X server is.
.TP
\fBDGA \fR
Uses the XFree86 DGA extension to do fullscreen direct
framebuffer access on X servers which support this. The bad thing
about the DGA extension is that it requires root access in order to
map \fI/dev/mem\fR, which means that you have to be
\fBroot\fR to use this target.

The display to connect to can be optionally specified.
Otherwise the display in \fBDISPLAY\fR is used.

The environment variable \fBGGI_DGA_FBDEV\fR is used to
specify a framebuffer device to \fBmmap\fR instead of 
\fI/dev/mem\fR.  This allows you to use the \fBDGA\fR target without root privileges!

Other features:

DirectBuffer always available.

Unaccelerated

Multiple frames

Panning
.TP
\fBaa \fR
Uses the AAlib <URL:http://horac.ta.jcu.cz/aa/aalib/>, an ASCII art
library, for output and input.

The standard AAlib \fBAA_OPTS\fR variable is parsed.

Other features:

DirectBuffer always available.

Unaccelerated
.TP
\fBfbdev \fR
Uses the Linux \fI/dev/fb*\fR devices to do
fullscreen graphics.

.sp
\fBdisplay-fbdev\fR \fB:\fR [ \fB-noinput\fR ]  [ \fB\fIframebuffer\fB\fR ] 
.RS
.TP
\fB\fIframebuffer\fB\fR
The filename of the framebuffer target to use.  The
default is to get it from the \fBFRAMEBUFFER\fR environment, or
the framebuffer associated with the current console if that is
unset.
.TP
\fB-noinput\fR
Do not open any input libraries by default.
.PP
.RE

Other features:

DirectBuffer always available.

Accelerated when using KGIcon or matroxfb.

Multiple frames

Panning
.TP
\fBfile \fR
Renders an image into a file.  The file can be a framebuffer
device (e.g. \fI/dev/fb0\fR), in which case a
reasonable representation of the image will be drawn on the console
\fBso long as\fR the program's mode matches the framebuffer's
mode.
.sp
.RS
.B "Note:"
This target generates no input !  The 
\fBmulti\fR target can be used in order to see
(and control) what the program does (using a normal target) and then 
generate a snapshot when the program exits.
.RE
.sp
.sp
\fBdisplay-file\fR \fB:\fR [ \fB-flushcmd="\fIcommand to execute\fB"\fR ]  [ \fB-flushframe=\fIn\fB\fR ]  [ \fB-flushtime=\fIt\fB\fR ]  \fB\fIfilename\fB\fR

\fIfilename\fR is the file to render the images to.  If
the filename is a PPM file (has the extension \fI.ppm\fR), then
the image will be generated at \fBggiClose\fR time.  Otherwise
the file is a custom `GGIFILE' format and is generated
continuously.

The \fBfile\fR target can be used to generate
movies from running LibGGI applications. To do this, set
\fB-flushcmd\fR to a shell command to execute at the times given by
one of the two other parameters. This looks typically like
ppmtogif foo.ppm >foo.%04d.gif. The command is passed through a 
\fBprintf\fR(3)
which has the current count of saved frames as an argument (or rather as
10 arguments to allow a few more complex commands).

This shell command is either executed at every
\fIn\fR-th invocation of ggiFlush or every \fIt\fR
seconds, where \fIt\fR can have fractional components.

Note, that the invocation of the shell command will slow down
the program, so make sure you use a reasonable value, if you use the
\fB-flushtime\fR argument.

The primary file is updated before every invocation of the shell
command.

Other features:

DirectBuffer always available.

Unaccelerated.
.TP
\fBglide \fR
Uses the Glide rasterisation library to display fullscreen on a 3DFX
graphics card.

The 3DFX card to use can be optionally specified as a number.
(0 means the first card, 1 the second, etc.)

Environment variables:
.RS
.TP
\fBGGI_GLIDE_MAXFREQ\fR
specifies the maximum update frequency your monitor
can handle (in Hz). Default is 70Hz.
.TP
\fBGGI_GLIDE_MAXHFREQ\fR
specifies the maximum horizontal frequency your monitor
can handle (in kHz). Default is 48kHz.
.TP
\fBGGI_GLIDE_HALTONSWITCH\fR
if this is set applications will be halted on
console switchaway. The default is to continue running.

.PP
.RE

Other features:

DirectBuffer never available.

Accelerated, one of the fastest targets when it comes to
drawing-primitives.

Multiple frames.
.TP
\fBmemory \fR
Emulates a linear framebuffer in main memory. This memory area
can be a shared memory segemnt, an area specified by the application, or be
\fBmalloc\fRed by the \fBmemory\fR target itself.

.sp
\fBdisplay-memory\fR \fB:\fR [ \fB-input\fR ]  [ \fB [ shmid:\fIsid\fB ]  [ keyfile:\fIsize\fB:\fIid\fB:\fIfname\fB ]  [ pointer ] \fR ] 
.RS
.TP
\fB\fI-input\fB\fR
If the "-input" option is set, an input buffer of
\fBINPBUFSIZE\fR as #define'd in
\fIggi/display/memory.h\fR (default is 8192 bytes) is
allocated at the start of the requested memory area. This is useful,
when running on shared memory, because it enables you to use
SendEvent to give input to other processes sharing that segment.
This is demonstrated in \fBcube3d\fR and can be used for
things like GGI multiplexers.
.TP
\fBshmid:\fIsid\fB\fR
use existing shared memory ID \fIsid\fR
.TP
\fBkeyfile:\fIsize\fB:\fIid\fB:\fIfname\fB\fR
create a new shm segment with id ftok(\fIfname\fR, \fIid\fR)
of size \fIsize\fR (preferred method !)
.TP
\fBpointer\fR
use the memory pointed to by \fIargptr\fR
(only available to applications calling \fBggiOpen\fR).
.PP
.RE
.sp
.RS
.B "Important:"
If you specify a memory area to use - be sure it's
big enough as no checks can or will be made that a certain mode fits
into it.
.PP
.RE
.sp

Other features:

DirectBuffer support always available.

Unaccelerated.
.TP
\fBsvgalib \fR
Uses the SVGAlib library to display fullscreen on a
VGA-compatible graphics card.

Other features:

DirectBuffer is available for the 320x200x8 mode.
For other modes, support is only available if SVGAlib supports linear
addressing.

Unaccelerated
.TP
\fBvcsa \fR
Uses the Linux \fI/dev/vcsa*\fR devices 
to render text modes onto the console.

.sp
\fBdisplay-vcsa\fR \fB:\fR [ \fB-shade\fR ]  [ \fB-ascii\fR ]  [ \fB\fIvcsa device\fB\fR ] 
.RS
.TP
\fB\fIvcsa device\fB\fR
The filename of the device file, defaulting to
\fI/dev/vcsa\fR which draws on the current virtual console.
.TP
\fB-shade\fR
The \fB-shade\fR option turns on `shading mode',
which changes the color mapping so that it chooses characters which
emulate a shading effect.  This makes a big improvement if using
(some might say abusing :) the \fBvcsa\fR
target for graphical purposes.
.TP
\fB-shade\fR
The \fB-ascii\fR option limits the color mapping
to only using ASCII characters.  The default mode uses IBM special
characters (the solid block mainly, and others when using
\fB-shade\fR).
.PP
.RE

Other features:

No DirectBuffer support.

Unaccelerated.
.SS "EMULATION TARGETS"
.PP
Emulation targets are those that run on top of one or more other targets.
.TP
\fBmonotext\fR
Emulates palettized modes (GT_PALETTE) on another target which
can only do text modes, by representing the graphics as ASCII characters.
The effect is the much the same as the \fBAAlib\fR
target, but does not depend on any external libraries.

.sp
\fBdisplay-monotext\fR \fB:\fR [ \fB [ -a=\fIaccuracy\fB ]  [  [ -x=\fIaccuracy\fB ]  [ -y=\fIaccuracy\fB ]  ] \fR ]  [ \fB\fItarget-spec\fB\fR ] 
.RS
.TP
\fB-x=\fIaccuracy\fB\fR
.TP
\fB-y=\fIaccuracy\fB\fR
A value between 1 and 5 which
determines how accurately to map the graphics to ASCII characters.
Lower values are less accurate, but can represent a wider range
of intensity levels.

The default is X=2 and Y=4.
.TP
\fB-a=\fIaccuracy\fB\fR
Same as above, but sets both the X and Y accuracy to
the specified value.
.PP
.RE

Other features:

DirectBuffer never supported.

Unaccelerated.
.TP
\fBmulti\fR
Duplicates all drawing operations onto multiple `child' targets,
producing identical output on multiple visuals.

.sp
\fBdisplay-multi\fR \fB:\fR \fB\fItarget-spec\fB:\fR\fI...\fR
Required: A colon (`:') separated list of target specs to draw on.
Because target specs can (and often do) contain colons, they need to be
enclosed in parentheses.

Other features:

DirectBuffer never supported.

Unaccelerated.
.TP
\fBpalemu\fR
Emulates palettized modes (\fBGT_PALETTE\fR) on another target which
can only do truecolor/greyscale/text modes or palettized modes of 
higher depth.

.sp
\fBdisplay-palemu\fR \fB:\fR [ \fB-parent=\fImode\fB\fR ]  \fB\fItarget-spec\fB\fR
.RS
.TP
\fB-parent=\fImode\fB\fR
Force the parent target to use a specific mode
(standard LibGGI mode string expected).
.TP
\fB\fItarget-spec\fB\fR
Specifies the target which to draw on (the `parent'
target).  This defaults to automatic selection (just like using 
\fBggiOpen\fR(\fBNULL\fR) when \fBGGI_DISPLAY\fR
is not set).
.PP
.RE

Other features:

DirectBuffer never supported.

Unaccelerated.
.TP
\fBtile\fR
Emulates one big target, splitting it up into `tiles' where each
tile is drawn on separate targets (the `children').

.sp
\fBdisplay-tile\fR \fB:\fR [ \fB [ -usedb ]  [ -nodb ] \fR ]  \fB\fIoffset-x\fB,\fIoffset-y\fB,\fIsize-x\fB,\fIsize-y\fB,\fIchild-target-spec\fB:\fR\fI...\fR
.RS
.TP
\fB\fIoffset-x\fB\fR
.TP
\fB\fIoffset-y\fB\fR
decimal values of the coordinates at which the tile
begins within the whole visual.
.TP
\fB\fIsize-x\fB\fR
.TP
\fB\fIsize-y\fB\fR
are decimal values for the size of the
tile within the whole visual.
.TP
\fB\fIchild-target-spec\fB\fR
a target spec.  Since target specs can (and often
do) contain colons, it needs to be enclosed in parentheses.
.TP
\fB-usedb\fR
enables the DirectBuffer emulation. This is the default.
DirectBuffer emulation works regardless of whether the child visuals
support DirectBuffer or not.
.TP
\fB-nodb\fR
disables the DirectBuffer emulation.
Instead, \fBLibGGI\fR primitives are passed to each of the
child visuals with the necessary clipping and translation.  Thus,
if a child visual supports acceleration, then the operation on that
area will be accelerated.
.PP
.RE
.TP
\fBtrueemu\fR
Emulates tes truecolor modes (\fBGT_TRUECOLOR\fR) on another target which can only
do palette modes or truecolor modes of different sizes/depths.  Uses
dithering and special palettes to get the highest possible quality.

.sp
\fBdisplay-trueemu\fR \fB:\fR [ \fB-parent=\fImode\fB\fR ]  [ \fB-dither=\fIdither\fB\fR ]  [ \fB-model=\fImodel\fB\fR ]  \fB\fItarget-spec\fB\fR
.RS
.TP
\fB-parent=\fImode\fB\fR
Force the parent target to use a specific mode
(standard LibGGI mode string expected).
.TP
\fB-dither=\fIdither\fB\fR
Specifies the amount of dithering.
Legal values are 0, 2 and 4, defaulting to 4.

When the target is running,
\fBCtrl\fR+\fBAlt\fR+\fBd\fR changes the dithering
level.
.TP
\fB-model=\fImodel\fB\fR
Color model to use (only when the parent is
palettized).  Legal values are rgb, cube and pastel.
Default depends on the parent mode.

When the target is running,
\fBCtrl\fR+\fBAlt\fR+\fBp\fR changes the current 
color model.
.TP
\fB\fItarget-spec\fB\fR
Specifies the target which to draw on (the `parent'
target).  This defaults to automatic selection (just like using 
\fBggiOpen\fR(\fBNULL\fR) when \fBGGI_DISPLAY\fR
is not set).
.PP
.RE

Other features:

DirectBuffer never supported.

Unaccelerated.
.SS "SPECIAL TARGETS"
.PP
These targets can only be opened explicitly by applications;
setting \fBGGI_DISPLAY\fR to one of these causes undefined behaviour.
.TP
\fBsub\fR
Creates a `child' visual within a "parent". This can be thought
of as a window and the \fBsub\fR target is intended
for simple windowing systems.

No textual arguments.  \fIargptr\fR must contain the parent
visual.

Other features:

DirectBuffer not supported.

Accelerated to the point of the parent. Calls are mapped
through with modified clipping and coordinates..

The sub target behaves a bit special with respect to the setmode call.
It uses the "visible" size for the top left corner position of the window
within the visual, and the "virtual" size for window width and height.
Note, that moving/resizing the window does _not_ cause any drawing action.
You have to perform those yourself. All it does for you is providing a
virtual visual within an existing one, which is convenient to allow for
window system canvases to be about any GGI program.
.SH "AUTHOR"

Various LibGGI hackers.

Converted to DocBook and man page by Steve Cheng
<steve@ggi-project.org>
.SH "SEE ALSO"

\fIenv.txt\fR and \fItargets.txt\fR from the LibGGI distribution
for any updates to the information here.

\fBlibgii\fR(7)

\fIThe LibGGI API Manual\fR
