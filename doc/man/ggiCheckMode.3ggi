.\\" auto-generated by docbook2man-spec $Revision: 1.5 $
.TH "ggiCheckMode" "3ggi" "22 August 2001" "GGI" "LibGGI API"
.SH NAME
ggiCheckMode, ggiCheckTextMode, ggiCheckGraphMode, ggiCheckSimpleMode \- Check or negotiate a text/graphics mode on a visual
.SH SYNOPSIS
\fB#include <ggi/ggi.h>
.sp
int ggiCheckMode(ggi_visual_t \fIvis\fB, 
ggi_mode *\fItm\fB);
.sp
int ggiCheckTextMode(ggi_visual_t \fIvisual\fB, 
int \fIcols\fB, int \fIrows\fB, 
int \fIvcols\fB, int \fIvrows\fB, 
int \fIfontx\fB, int \fIfonty\fB, 
ggi_mode *\fIsuggested_mode\fB);
.sp
int ggiCheckGraphMode(ggi_visual_t \fIvisual\fB, 
int \fIx\fB, int \fIy\fB, 
int \fIxv\fB, int \fIyv\fB, 
ggi_graphtype \fItype\fB, 
ggi_mode *\fIsuggested_mode\fB);
.sp
int ggiCheckSimpleMode(ggi_visual_t \fIvisual\fB, 
int \fIx\fB, int \fIy\fB, 
int \fIframes\fB, 
ggi_graphtype \fItype\fB, 
ggi_mode *\fIsuggested_mode\fB);
\fR.SH "DESCRIPTION"
.PP
\fBggiCheckMode\fR checks whether or not the given mode will work
on the visual. If it does not work, it will modify the values of passed
\fBggi_mode\fR structure so that the mode works. This mode
negotiation allows the application to discover modes that are both
supported by the visual and suitable to the application.
.PP
\fBggiCheckTextMode\fR checks whether the text mode with the given
visible and virtual dimensions and the font size is supported.
.PP
\fBggiCheckGraphMode\fR checks whether the graphics mode with the
given visible and virtual dimensions and type is supported.
.PP
\fBggiCheckSimpleMode\fR checks wheter the graphics mode with the
given visible dimensions, type, and number of buffers is supported.
This is used in lieu of \fBggiCheckGraphMode\fR if multiple
buffering is desired.
.PP
For \fBggiCheckTextMode\fR, \fBggiCheckGraphMode\fR and
\fBggiCheckSimpleMode\fR, \fIsuggested_mode\fR is either
\fBNULL\fR or a pointer to a \fBggi_mode\fR which will be
filled in with the negotiated mode parameters. 
.SH "RETURN VALUE"
.PP
For \fBggiCheckTextMode\fR and \fBggiCheckGraphMode\fR, a
return of 0 means that the corresponding set mode call for
this mode would succeed. Otherwise, the mode given cannot be set. In
this case, \fIsuggested_mode\fR is changed to the suggested mode.
.PP
If the only modifications made to the structure is replacing
\fBGGI_AUTO\fR or \fBGT_AUTO\fR value, the functions return
success.
.SH "RULES FOR MODE NEGOTIATION"
.PP
First, if \fBGGI_AUTO\fR (or \fBGT_AUTO\fR for the graphtype) is
specified for any of the members of \fI*tm\fR, these are filled in
with the recommended values. The values could be to a maximum,
preferred, or \fBGGI_DEFMODE\fR resolution, and will be compatible
with any other constraints. 
.PP
An application that does not care about a specific paramater should
always specify \fBGGI_AUTO\fR or \fBGT_AUTO\fR for it.
.PP
The resulting mode is guaranteed to be valid; if not, the application
can assume that it cannot set any mode on the given visual and give up.
.PP
The suggested mode is derived as follows:
.TP 0.2i
\(bu
Resolutions are always adjusted \fBup\fR. If you want the
next lower, start out at 1x1 (or somewhere else reasonable) and jump up
the ladder.

Only if the maximum resolution would be exceeded, resolutions are
adjusted \fBdown\fR to the maximum.

The above applies to visible and virtual size. If there is interference
between them, the visible size is satified first if possible, then the
virtual size.

The adjustment of one value do not normally affect other values. For
example, if (visible) 320x100 (virtual 320x200) is requested, the
visible size may be adjusted to 320x200, but virtual size will be left
alone. Of course, if the virtual size becomes less than visible size,
then it will be adjusted as well. 
.TP 0.2i
\(bu
Font sizes are handled the other way round: they are adjusted
\fBdown\fR except when there is nothing below.
.TP 0.2i
\(bu
A specific graphtype is changed only if the card does not support it
\fBat all\fR. If the maximum resolution is exceeded, then that is
adjusted down and not the graphtype. This assumes, that if you request
true-color, you really want that and not so badly the resolution you
requested. If this is not the case, you can still retry with another
graphtype or \fBGT_AUTO\fR.

If graphtype is changed, it is adjusted in ascending order if possible:
e.g. i.e. 1->4->8->15->16->24/32 bit. So you always get a mode which can
do more than you requested. Only when no better modes are available, the
type is adjusted down.
.SH "EXAMPLES"
.SS "TRY A 320X200X8 MODE"
.sp
.nf
err = ggiCheckGraphMode(vis, 320, 200, GGI_AUTO, GGI_AUTO, GT_8BIT, 
                        &sug_mode, NULL);
if(err) {
        \fI/* Check if returned mode is ok... */\fR
}
else {
        ggiSetMode(&sug_mode);
}
.sp
.fi
.SH "SEE ALSO"
\fBggiOpen\fR(3), [XRef to GGISETMODE]
