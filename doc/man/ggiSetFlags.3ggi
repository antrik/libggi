.\\" auto-generated by docbook2man-spec $Revision: 1.4 $
.TH "ggiSetFlags" "3ggi" "14 August 2001" "GGI" "LibGGI API"
.SH NAME
ggiSetFlags, ggiGetFlags, ggiAddFlags, ggiRemoveFlags \- Set or get flags affecting operation on a visual
.SH SYNOPSIS
\fB#include <ggi/ggi.h>
.sp
int ggiSetFlags(ggi_visual_t \fIvis\fB, ggi_flags \fIflags\fB);
.sp
ggi_flags ggiGetFlags(ggi_visual_t \fIvis\fB);
.sp
int ggiAddFlags(ggi_visual_t \fIvis\fB, ggi_flags \fIflags\fB);
.sp
int ggiRemoveFlags(ggi_visual_t \fIvis\fB, ggi_flags \fIflags\fB);
\fR.SH "DESCRIPTION"
.PP
\fBggiSetFlags\fR sets the specified flags (bitwise OR'd together) on a
visual. This function is usually used to set async mode on a visual (see
below).
.PP
\fBggiGetFlags\fR obtains the flags currently in effect.
.PP
\fBggiAddFlags\fR and \fBggiRemoveFlags\fR are macros that
set or unsets the specified flags.
.SH "RETURN VALUE"
.PP
\fBggiSetFlags\fR, \fBggiAddFlags\fR, and
\fBggiRemoveFlags\fR return 0 on success,
<0 on failure.
.PP
\fBggiGetFlags\fR returns the current flags.
.SH "SYNCHRONOUS AND ASYNCHRONOUS DRAWING MODES"
.PP
Some visuals allow different modes with regard to when the screen is updated
and the actual drawing takes place.
.TP 0.2i
\(bu
In synchronous mode when the drawing command returns, it is already or
will be executed very shortly. So the visible effect is that everything
is drawn immediately. (It is not guaranteed in the strict sense in that
it is already drawn when the function call returns, but almost.)
This is the default mode for all visuals.
.TP 0.2i
\(bu
The asynchronous mode does not guarantee that drawing commands are
executed immediately, but is faster on many targets. 
If the visual does not support asynchronous mode, setting it has no
effect. 

To make sure that all pending graphics operations are actually done and
the screen is updated, you need to call \fBggiFlush\fR. This call is not needed in synchronous mode.)
.sp
.RS
.B "Warning:"
.PP
On some targets such as the X target there is no real synchronous mode,
so LibGGI fakes one by periodically calling \fBggiFlush\fR in the
background. This process can take about half the execution time of a program. 
So using synchronous mode can \fBreally\fR slow things down.
.PP
The synchronous mode is default because it is what most programmers
expect.
.PP
.RE
.sp
.PP
All operations are guaranteed to be performed in the
order given in both modes. Reordering is not done.
.PP
.PP
So the recommendation for all graphics applications is to set the
asynchronous mode. It will be far more efficient on some platforms and will
\fBnever\fR be worse. 
.PP
.SS "SETTING UP ASYNCHRONOUS MODE"
.sp
.nf
ggiAddFlags(vis, GGIFLAG_ASYNC);	/* switches to asynchronous mode */

ggiFlush(vis);				/* updates the screen */

ggiRemoveFlags(vis, GGIFLAG_ASYNC);	/* switches to synchronous mode */
.sp
.fi
.PP
.SH "SEE ALSO"
[XRef to GGIFLUSH]
