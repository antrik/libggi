.\"Generated by db2man.xsl. Don't modify this, modify the source.
.de Sh \" Subsection
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Ip \" List item
.br
.ie \\n(.$>=3 .ne \\$3
.el .ne 3
.IP "\\$1" \\$2
..
.TH "GGIGETC" 3ggi "" "" ""
.SH NAME
ggiGetc, ggiKbhit \- Convenience functions for simplistic keyboard input
.SH "SYNOPSIS"
.ad l
.hy 0

#include <ggi/ggi.h>
.sp
.HP 7
int\ ggiGetc\ (ggi_visual_t\ \fIvis\fR);
.HP 14
int\ \fBggiKbhit\fR\ (ggi_visual_t\ \fIvis\fR);
.ad
.hy

.SH "DESCRIPTION"

.PP
 \fBggiGetc\fR gets a character from the keyboard, and blocks if there is no key immediately available.

.PP
 \fBggiKbhit\fR checks if a key has been hit on the keyboard. This does not consume the key. It is used for easy porting of old DOS applications. .RS .Sh "Important" .PP Do not poll like this: do while( ! ggiKbhit(vis) ); On a multitasking OS you would be wasting a lot of resources which could be available to other processes. If you want to wait for a key, use the \fBggiGetc\fR call. .RE 

.SH "RETURN VALUE"

.PP
 \fBggiKbhit\fR returns 0 if no key has been received yet, otherwise there is a key to be consumed.

.PP
 \fBggiGetc\fR returns a Unicode character in canonical form.

.PP
For a fuller definition of characters, see .

.SH "SEE ALSO"

